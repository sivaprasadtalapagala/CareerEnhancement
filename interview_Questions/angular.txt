===================What is ,angularFramework?(,framework)======================
Angular is a TypeScript-based open-source front-end platform that makes it easy to build applications with in web/mobile/desktop.
The major features of this framework such as declarative templates, dependency injection, end to end tooling, and many more other features are used to ease the
development.

its primary purpose is to develop single-page applications


====================================,Single Page Applications (SPA)?(,spa)

direct answer:Angular changes the content dynamically without reloading the page

The index.html is loaded once.

Clicking links doesn‚Äôt reload the page.

Angular changes the content dynamically using routes and components.



Single-page applications are web applications that load once with new features just being mere additions to the user interface. It does not load new HTML pages to display the new page's content, instead generated dynamically. This is made possible through JavaScript's ability to manipulate the DOM elements on the existing page itself. A SPA approach is faster, thus providing a seamless user experience. 


A Single Page Application (SPA) is a web app that:

Loads a single HTML page once, and

Dynamically updates the content without reloading the whole page when the user navigates.

‚úÖ In Angular, SPA is achieved using its routing system (@angular/router).



=====================What is the difference between AngularJS ,vs Angular?=====================================

Angular is a completely revived component-based framework in which an application is a tree of individual components.
Some of the major difference in tabular form
        AngularJS	                                                                                  Angular
It is based on MVC architecture	                                                     This is based on components and services based architecture
It uses JavaScript to build the application	                                         Introduced the TypeScript to write the application
Based on controllers concept	                                                       This is a component based UI approach
Not a mobile friendly framework	                                                     Developed considering mobile platform
Difficulty in SEO friendly application development	                                 Ease to create SEO friendly applications
doesn't officially support lazy loading of components, services, etc                 support lazy loading of components, services, etc
Angular js                                                                           Angular cli 
1X                                                                                   2,4,5,6,7,8,9,....14



==================================== ,metadata in components ===================

In Angular, metadata in components refers to the information you provide to the Angular compiler to describe how the component should behave. This metadata is defined using a decorator, most commonly @Component, which tells Angular that the class is a component and provides configuration options.

üìå Example of Metadata in an Angular Component
ts
Copy
Edit
import { Component } from '@angular/core';

@Component({
  selector: 'app-hello-world',          // Tag name to use in HTML
  templateUrl: './hello-world.component.html', // HTML template path
  styleUrls: ['./hello-world.component.css'],  // CSS files for styling
})
export class HelloWorldComponent {
  message = 'Hello, Angular!';
}
üîç Metadata Properties in @Component
Property	Description
selector	HTML tag used to include this component in templates.
templateUrl	Path to external HTML file used as the template.
template	Inline HTML string (used instead of templateUrl).
styleUrls	Array of paths to external CSS/SCSS files.
styles	Inline styles as an array of strings.
providers	Array of services/providers available only to this component and its view.
animations	Defines the animations used in the component.
encapsulation	Controls view encapsulation (None, Emulated, ShadowDom).
changeDetection	Defines change detection strategy (Default or OnPush).
imports	(Angular 14+) Allows importing standalone components, pipes, directives.
standalone	(Angular 14+) Marks the component as standalone.


==================What are Annotations(,annotations) in Angular?=========
In Angular, annotations are special pieces of information that you add to your TypeScript code using decorators. Decorators are the functions that start with the @ symbol. Annotations help Angular understand and configure different aspects of your code, such as classes, methods, or properties. They provide metadata that Angular uses for various purposes, like defining components, services, or specifying how dependency injection should work.

Here are a couple of simple examples:

@Component Annotation:

This annotation is used to define an Angular component. It provides metadata about how the component should behave, its template, and its styles.

@Injectable Annotation:

This annotation is used for services in Angular. It tells Angular that a class can be injected with dependencies.



Visual relationship
Decorators (big set ‚Üí TypeScript feature)
    |
    |--- Angular-specific decorators (@Component, @Injectable, @NgModule...)
             |
             ---> Produce Annotations (metadata Angular understands)


‚úÖ Final Answer:
Annotations are a subset of decorators ‚Äî they are the Angular-specific metadata that result from applying Angular decorators.






============================,decorators in Angular? 

Decorators are a design pattern or functions that define how Angular features work. They are used to make prior modifications to a class, service, or filter. Angular supports four types of decorators, they are:

Class Decorators
Property Decorators
Method Decorators
Parameter Decorators


@decorators

=====================Class Decorators

@NgModule

@Component

@Injectable

@Directive

@Pipe

====================Method Decorators

@HostListener

===================Parameter Decorators

@Inject

@Self

@SkipSelf

@Optional

@Host

====================Property Decorators

@Input

@Output

@HostBinding

@ContentChild

@ContentChildren

@ViewChild

@ViewChildren




or

Decorators are design patterns used to isolate the modification or decoration of a class without modifying the source code.

In AngularJS, decorators are functions that allow a service, directive, or filter to be modified before it is used.

*In Angular, decorators are a way to enhance and modify the behavior of classes, methods, or properties. They are often used to provide metadata and configuration to Angular components, services, and modules. Decorators are functions that are prefixed with the @ symbol and are applied to classes, methods, or properties using TypeScript.

There are four main types of angular decorators:

Class decorators, such as @Component and @NgModule
Property decorators for properties inside classes, such as @Input and @Output,@ViewChild / @ViewChildren
Method decorators for methods inside classes, such as @HostListener
Parameter decorators for parameters inside class constructors, such as @Inject

============================,classDecorator   1. Class Decorators

These are applied to classes (like components, modules, services).

@NgModule
Defines an Angular module. It groups components, directives, pipes, and services together.

@NgModule({
  declarations: [AppComponent, HomeComponent],
  imports: [BrowserModule, FormsModule],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}


@Component
Turns a class into a component with template + styles.

@Component({
  selector: 'app-hello',
  template: `<h1>Hello Angular!</h1>`
})
export class HelloComponent {}


@Injectable
Marks a class as a service that can be injected into other classes.

@Injectable({
  providedIn: 'root'
})
export class UserService {
  getUser() { return "John"; }
}


@Directive
Creates a custom directive (to change behavior/appearance of DOM elements).

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.background = 'yellow';
  }
}


@Pipe
Defines a pipe (for transforming data in templates).

@Pipe({name: 'uppercaseFirst'})
export class UppercaseFirstPipe implements PipeTransform {
  transform(value: string): string {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
}

============================,methodDecorator 2. Method Decorators

@HostListener
Listens to DOM events on the host element.

@Directive({ selector: '[appClickTracker]' })
export class ClickTrackerDirective {
  @HostListener('click', ['$event'])
  onClick(event: Event) {
    console.log('Element clicked!', event);
  }
}

============================,parameterDecorator  3. Parameter Decorator

üß© 1. @Inject

Think like this:
Normally, Angular gives you a service class.
But sometimes, you just want to inject a value (like a string or number).

Example:

@NgModule({
  providers: [
    { provide: 'API_URL', useValue: 'https://api.example.com' }
  ]
})
export class AppModule {}


Now in your service:

constructor(@Inject('API_URL') private apiUrl: string) {
  console.log(this.apiUrl); // shows: https://api.example.com
}


üü¢ Simple meaning:
We tell Angular ‚Äî ‚ÄúHey, inject this specific value instead of a class.‚Äù





üß© 2. @Self

Think like this:
Angular looks for what you need (like a service or form control) in many places ‚Äî first near your component, then in parents, then higher up.

But if you use @Self,
you tell Angular ‚Äî ‚ÄúLook only near me, not in parents.‚Äù

Example:
You made a custom input component and want to check if there‚Äôs a FormControl directly on it.

constructor(@Self() private formControl: NgControl) {
  console.log(formControl); // will be found only if this component itself has one
}


üü¢ Simple meaning:
Only look for the service inside this component, not above it.





üß© 3. @SkipSelf

Opposite of @Self

Think like this:
If both parent and child have the same service,
and you say @SkipSelf,
you tell Angular ‚Äî ‚ÄúSkip mine, get from my parent.‚Äù

Example:

@Component({
  selector: 'parent',
  providers: [MyService],
  template: `<child></child>`
})
export class Parent {}

@Component({
  selector: 'child',
  providers: [MyService],
  template: `<p>child</p>`
})
export class Child {
  constructor(@SkipSelf() private service: MyService) {
    console.log('Got parent‚Äôs service');
  }
}


üü¢ Simple meaning:
‚ÄúDon‚Äôt use my own version ‚Äî take it from the parent.‚Äù





üß© 4. @Optional

Think like this:
If the service is missing, Angular usually gives an error.
But with @Optional, you say ‚Äî
‚ÄúIt‚Äôs okay if you don‚Äôt find it, just continue.‚Äù

Example:

constructor(@Optional() private logger?: LoggerService) {
  this.logger?.log('App started');
}


If LoggerService is not there, it won‚Äôt crash.
It just skips logging.

üü¢ Simple meaning:
‚ÄúIt‚Äôs fine if you can‚Äôt find this service ‚Äî I‚Äôll manage.‚Äù





üß© 5. @Host

Think like this:
When a small directive or component lives inside a bigger one,
you say ‚Äî ‚ÄúGet the service only from the one I‚Äôm inside (host), not from further up.‚Äù

Example:

@Component({
  selector: 'host-comp',
  providers: [HostService],
  template: `<child-dir></child-dir>`
})
export class HostComponent {}

@Directive({
  selector: 'child-dir'
})
export class ChildDirective {
  constructor(@Host() private hostService: HostService) {
    this.hostService.sayHi();
  }
}


üü¢ Simple meaning:
‚ÄúUse the service from the component I‚Äôm directly inside, not from others above it.‚Äù

üß† Summary in one line each
Decorator	Simple meaning
@Inject	Get a specific value (like a string or number).
@Self	Get it only from this component, not parents.
@SkipSelf	Get it from the parent, not from this component.
@Optional	Okay if it‚Äôs missing, don‚Äôt throw error.
@Host	Get it only from the host component I‚Äôm inside.



============================,propertyDecorator    4. Property Decorators

@Input
Pass data from parent ‚Üí child component.

@Input() userName: string = '';


@Output
Send events from child ‚Üí parent.

@Output() userClicked = new EventEmitter<string>();


@HostBinding
Bind a property to a host element attribute/style/class.

@Directive({ selector: '[appActive]' })
export class ActiveDirective {
  @HostBinding('class.active') isActive = true;
}


@ContentChild
Get a reference to the first projected child.

@ContentChild('projected') content: ElementRef;


@ContentChildren
Get references to all projected children.

@ContentChildren('item') items: QueryList<ElementRef>;


@ViewChild
Get reference to a child component/directive inside the template.

@ViewChild(ChildComponent) child: ChildComponent;


@ViewChildren
Get multiple child references.

@ViewChildren(ChildComponent) children: QueryList<ChildComponent>;


‚úÖ In short:

Class Decorators ‚Üí Define components, services, modules.

Method Decorators ‚Üí Listen to host events.

Parameter Decorators ‚Üí Control how dependencies are injected.

Property Decorators ‚Üí Handle inputs, outputs, child references.




===================================================================================================================================================================



===================What is ,typeScript?======================================
TypeScript is a typed superset of JavaScript created by Microsoft that adds optional types, classes, async/await, and many other features, and compiles to plain JavaScript.
 Angular built entirely in TypeScript and used as a primary language.
  You can install it globally as
npm install -g typescript
Let's see a simple example of TypeScript usage,
function greeter(person: string) {
    return "Hello, " + person;
}

let user = "Sudheer";

document.body.innerHTML = greeter(user);
The greeter method allows only string type as argument.




=======================================What are the ,keyComponents of Angular?
Angular has the below key components,
   Component: These are the basic building blocks of angular application to control HTML views.
   Modules: An angular module is set of angular basic building blocks like component, directives, services etc. An application is divided into logical pieces and 
             each piece of code is called as "module" which perform a single task.
   Templates: This represent the views of an Angular application.
   Services: It is used to create components which can be shared across the entire application.
   Metadata: This can be used to add more data to an Angular class.



=========================What is Angular ,directive =============
The Angular directive helps us to manipulate the DOM. You can change the appearance, behavior, or layout of a DOM element using the Directives. 
They help you to extend HTML

There are three kinds of directives in Angular:

Component Directive
Structural directives
Attribute directives

                 -------------,componentDirective?------------ 

Component directive, is nothing but a simple class which is decorated with the @component decorator.
In Angular 2 ,Normal typescript class will become a Component class once it has been decorated with @component decorator
It is mainly used to specify the html templates.
It is most commonly used directive in angular project


                 --------------,structural Directives
Structural directives can change the DOM layout by adding and removing DOM elements. All structural Directives are preceded by Asterix symbol

Commonly used structural directives
                          ---,ngFor
ng For is used to iterate over a list of items 
Example of ngFor
<tr *ngFor="let customer of customers;">
    <td>{{customer.customerNo}}</td>
    <td>{{customer.name}}</td>
    <td>{{customer.address}}</td>
    <td>{{customer.state}}</td>
</tr>

  customers: customer[] =[
 
  {customerNo:13,name:' B',address:'C',state:'D'}, 
    {customerNo:'A',name:' B',address:'C',state:'D'}, 
	  {customerNo:'A',name:' B',address:'C',state:'D'}, 
	    {customerNo:'A',name:' B',address:'C',state:'D'}, 
]
 
 
}
 
class customer {
  customerNo : number;
  name : string;
  address : string;
  state : string;
}


=============================What is the purpose of ngFor trackBy?(,ngForTrackBy)(,trackBy)
The main purpose of using *ngFor with trackBy option is performance optimization. Normally if you use NgFor with large data sets, a small change to one item by removing or adding an item, can trigger a cascade of DOM manipulations. In this case, Angular sees only a fresh list of new object references and to replace the old DOM elements with all new DOM elements. You can help Angular to track which items added or removed by providing a trackBy function which takes the index and the current item as arguments and needs to return the unique identifier for this item.

For example, lets set trackBy to the trackByTodos() method

<div *ngFor="let todo of todos; trackBy: trackByTodos">
  ({{todo.id}}) {{todo.name}}
</div>
and define the trackByTodos method,

trackByTodos(index: number, item: Todo): number { return todo.id; }


                           ------,ngIf
The ngIf Directives is used to add or remove HTML elements based on an expression/condition.
The expression must return a boolean value.
If the expression is false then the element is removed, else the element is inserted

Example of ngIf
<div *ngIf="condition"> 
    This is shown if condition is true
</div>



       --------What is Angular NgSwitch?(,ngSwitch)---------------- 

The NgSwitch directive is used for conditional rendering based on multiple conditions.
html
Copy code
<!-- Render different content based on the value of condition -->
import { Component } from '@angular/core';

@Component({
  selector: 'app-example',
  template: `
    <div [ngSwitch]="condition">
      <div *ngSwitchCase="'case1'">Content for Case 1</div>
      <div *ngSwitchCase="'case2'">Content for Case 2</div>
      <div *ngSwitchDefault>Default Content</div>
    </div>
  `,
})
export class ExampleComponent {
  condition: string = 'case1'; // You can change this value to see different cases
}


The NgSwitch directive specifies an expression to match against. The NgSwitchCase directive defines the expressions to match.

It renders every view that matches.
If there are no matches, the view with the NgSwitchDefault directive is rendered.
Elements outside of any NgSwitchCase or NgSwitchDefault directive but within the NgSwitch statement but are preserved at the location.


------------------,ngDisabled:
The NgDisabled directive is used to disable or enable an input element based on a condition.
html
Copy code
<!-- Disable the button if isDisabled is true -->
<button [disabled]="isDisabled">Click me</button>


---------------,ngHref:
The NgHref directive is used to dynamically set the href attribute of an anchor (<a>) element.
<!-- Set the href dynamically based on the linkUrl variable -->
import { Component } from '@angular/core';

@Component({
  selector: 'app-example',
  template: `
    <a [attr.href]="linkUrl">Visit our website</a>
  `,
})
export class ExampleComponent {
  linkUrl: string = 'https://www.example.com';
}



        ------------------------------,attributeDirectives
An Attribute or style directive can change the appearance or behavior of an element.

Commonly used Attribute directives:-

               ----,ngModel
The ngModel directive is used the achieve the two-way data binding.It binds the value of an input element to a variable in the component and keeps them in sync.We have covered ngModel directive in Data Binding in Angular Tutorial
ex:-

import { FormsModule } from '@angular/forms';
  
<input type="text" name="value" [(ngModel)]="value">


               ----,ngModelChange
In Angular, ngModelChange is an event that is emitted when the value of a two-way data-bound input property (using [(ngModel)]) changes. It's often used in conjunction with the ngModel directive to capture and respond to changes in the input field.

Let's break it down with a real-time example:

Suppose you have an input field in your Angular component that is bound to a variable using ngModel like this:

html
Copy code
<input [(ngModel)]="myValue" (ngModelChange)="onValueChange($event)">


               ----Change Event(,changeEvent)

In Angular, the (change) event is commonly used to capture and respond to changes in an HTML element, such as an input field. This event is triggered when the user interacts with the element and its value changes.

<input type="text" (change)="onInputChange($event)">

 onInputChange(event: any) {
    // Do something with the changed value, for example, log it.
    console.log('Input changed:', event.target.value);
  }


               -----------,ngClass
The NgClass directive allows you to conditionally apply CSS classes to an element based on expression evaluation.
html
Copy code
<!-- Apply 'active' class if isActive is true, otherwise apply 'inactive' class -->
<div [ngClass]="{'active': isActive, 'inactive': !isActive}">Toggle Class</div>

The ngClass is used to add or remove the CSS classes from an HTML element. Using the ngClass one can create dynamic styles in HTML pages

Example of ngClass
 
<div [ngClass]="'first second'">...</div>
               css file 
    .red { color: red; }
    .size20 { font-size: 20px; }

               .html 
     <div [ngClass]="'red size20'"> Red Text with Size 20px </div>
     (or)
     <div class="row">     
        <div ngClass='red size20'>Red Text with Size 20px </div> 
     </div>
 
                ------------,ngStyle

The NgStyle directive lets you conditionally apply inline styles to an element based on expression evaluation.
html
Copy code
<!-- Apply red color if isError is true, otherwise apply green color -->
<div [ngStyle]="{'color': isError ? 'red' : 'green'}">Dynamic Style</div>

ngStyle is used to change the multiple style properties of our HTML elements. 
We can also bind these properties to values that can be updated by the user or our components.

Example of ngStyle

<div [ngStyle]="{'color': 'blue', 'font-size': '24px', 'font-weight': 'bold'}">
    some text
</div>

               -----------------,Custom Directives(,customDirectives)
Apart from build in directives we can also build custom directives in Angular. 
The Process is to create a JavaScript class and apply the @Directive attribute to that class.
 You can write the desired behavior in the class.

Angular custom directives are user-defined directives that allow you to extend or create new behaviors in your Angular applications. They are a powerful feature that lets you encapsulate and reuse functionality in your templates. There are two types of custom directives in Angular: attribute custom directives and structural custom directives.

Attribute custom Directives:
Example 1: Highlight Directive
Let's create a simple attribute directive that highlights the background color of an element based on a specified color.

typescript
Copy code
// highlight.directive.ts
import { Directive, ElementRef, Input, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  @Input() highlightColor: string = 'yellow';

  constructor(private el: ElementRef, private renderer: Renderer2) {}

  ngOnInit() {
    this.renderer.setStyle(this.el.nativeElement, 'background-color', this.highlightColor);
  }
}
html
Copy code
<!-- app.component.html -->
<div appHighlight [highlightColor]="'lightblue'">This will be highlighted</div>
<div>This won't be highlighted</div>
In this example, the HighlightDirective sets the background color of an element to the specified color. The directive is applied to an element using the appHighlight attribute, and the highlightColor input allows you to customize the color.

Structural custom Directives:
Example: AuthDirective
typescript
Copy code
// auth.directive.ts
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appAuth]'
})
export class AuthDirective {
  // Assume this is a boolean indicating whether the user is logged in or not
  private isLoggedIn: boolean = false;

  constructor(private templateRef: TemplateRef<any>, private viewContainer: ViewContainerRef) {}

  @Input() set appAuth(condition: boolean) {
    if (condition === this.isLoggedIn) {
      this.viewContainer.createEmbeddedView(this.templateRef);
    } else {
      this.viewContainer.clear();
    }
  }
}
html
Copy code
<!-- app.component.html -->
<div *appAuth="true">
  Welcome! You are logged in.
</div>

<div *appAuth="false">
  Please log in to view this content.
</div>
In this example, the AuthDirective is a structural directive that conditionally renders content based on whether the user is logged in (true) or not (false). If the value provided to appAuth matches the current login status, the content inside the directive will be displayed; otherwise, it will be removed.

This demonstrates the flexibility of structural directives in managing the structure of your templates based on dynamic conditions.

 
==================change detection in angular(,changeDetection) ==========

Default Change Detection:
Angular's default change detection strategy is to check the components' properties and their children's properties for changes. If any changes are detected, Angular updates the view.

Example:

typescript
Copy code
@Component({
  selector: 'app-example',
  template: '<p>{{ data }}</p>',
})
export class ExampleComponent {
  data: string = 'Initial value';
}
OnPush Change Detection:
You can change the change detection strategy to OnPush for a component. With OnPush, Angular will only check for changes when:

The component's input properties change.
The component raises an event.
An observable bound to the template emits a new value.
Example:

typescript
Copy code
@Component({
  selector: 'app-example',
  template: '<p>{{ data }}</p>',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ExampleComponent {
  @Input() data: string = 'Initial value';
}
ChangeDetectorRef:
The ChangeDetectorRef service allows you to manually trigger change detection for a component.

Example:

typescript
Copy code
import { ChangeDetectorRef } from '@angular/core';

constructor(private cdr: ChangeDetectorRef) { }

// Trigger change detection manually
detectChanges() {
  this.cdr.detectChanges();
}
Immutable Data:
Using immutable data structures can help with change detection. If you always create new objects or arrays when updating data, Angular's change detection can easily identify the changes.

Async Pipe:
When working with observables, the async pipe automatically triggers change detection when a new value is emitted.

Example:

typescript
Copy code
import { Observable } from 'rxjs';

data$: Observable<string>;

// In the template
<p>{{ data$ | async }}</p>
NgDoCheck:
Implementing the ngDoCheck lifecycle hook allows you to perform custom change detection logic.

Example:

typescript
Copy code
ngDoCheck() {
  // Custom change detection logic
}
Remember that Angular's default change detection is highly optimized, and in most cases, you don't need to manually intervene. However, understanding these techniques can be helpful in scenarios where you need more control over change detection behavior.



 ================================,What are components?(,components)

Components are the most basic UI building block of an Angular app to control HTML views,which formed a tree of Angular components.
 These components are subset of directives. 
 Unlike directives, components always have a template and only one component can be instantiated per an element in a template. 




======================================differences between Component ,vs Directive?=======================(component ,vsCD ,vsDC directives)

  In a short note, A component(@component) is a directive-with-a-template.
                                    Component	                                                                           Directive
 To register a component we use @Component meta-data annotation	                          To register directives we use @Directive meta-data annotation
 Components are typically used to create UI widgets	                                      Directive is used to add behavior to an existing DOM element
 Component is used to break up the application into smaller components	                  Directive is use to design re-usable components
 Only one component can be present per DOM element	                                      Many directives can be used per DOM element
 @View decorator or templateurl/template are mandatory	                                  Directive doesn't use View



 =================================================,template=====================

A template is a HTML view where you can display data by binding controls to properties of an Angular component.
You can store your component's template in one of two places.
You can define it inline using the template property, or you can define the template in a separate HTML file and link to it in the component metadata using 
the @Component decorator's templateUrl property.



===========================================What is an Angular ,module?

In Angular, a module is a mechanism to group components, directives, pipes and services that are related, in such a way that can be combined with other modules to
create an application. 
An Angular application can be thought of as a puzzle where each piece (or each module) is needed to be able to see the full picture.

Another analogy to understand Angular modules is classes. 
In a class, we can define public or private methods. 
The public methods are the API that other parts of our code can use to interact with it while the private methods are implementation details that are hidden. 

In the same way, a module can export or hide components, directives, pipes and services. 
The exported elements are meant to be used by other modules, while the ones that are not exported (hidden) are just used inside the module itself and cannot be 
  directly accessed by other modules of our application.

A Basic Use of Modules
To be able to define modules we have to use the decorator NgModule.
import { NgModule } from '@angular/core';
‚Äã
@NgModule({
  imports: [ ... ],
  declarations: [ ... ],
  bootstrap: [ ... ]
})
export class AppModule { }
In the example above, we have turned the class AppModule into an Angular module just by using the NgModule decorator. 
The NgModule decorator requires at least three properties: imports, declarations and bootstrap.
The property imports expects an array of modules. Here's where we define the pieces of our puzzle (our application). 
The property declarations expects an array of components, directives and pipes that are part of the module. 
The bootstrap property is where we define the root component of our module. 
Even though this property is also an array, 99% of the time we are going to define only one component.
There are very special circumstances where more than one component may be required to bootstrap a module but we are not going to cover those edge cases here.


The NgModule decorator has five important(among all) options

The imports option is used to import other dependent modules. The BrowserModule is required by default for any web based angular application
The declarations option is used to define components in the respective module
The bootstrap option tells Angular which Component to bootstrap in the application
The providers option is used to configure set of injectable objects that are available in the injector of this module.
The entryComponents option is a set of components dynamically loaded into the view.


===========================================What are ,lifecycle hooks available?=============

 8 lifecycle method is as below,

ngOnChanges: When the value of a data bound property changes, then this method is called,called befpre ngonit.
ngOnInit: This is called whenever the initialization of the directive/component after Angular first displays the data-bound properties happens.
ngDoCheck: This is for the detection and to act on changes that Angular can't or won't detect on its own.
ngAfterContentInit: This is called in response after Angular projects external content into the component's view.
ngAfterContentChecked: This is called in response after Angular checks the content projected into the component.
ngAfterViewInit: This is called in response after Angular initializes the component's views and child views.
ngAfterViewChecked: This is called in response after Angular checks the component's views and child views.
ngOnDestroy: This is the cleanup phase just before Angular destroys the directive/component.
             If we don‚Äôt clean up, intervals or subscriptions keep running in background even after component is destroyed ‚Üí leads to memory leaks and app slowing down.







=====ngDoCheck ====

By default, Angular detects changes by reference for objects/arrays.
That means Angular only knows if you replaced the entire object/array, not if you mutated it.

Example:

this.items.push("new item");


Angular does not detect that the contents of the array changed, because the reference (this.items) is the same.

üëâ ngDoCheck lets you write custom logic to notice those ‚Äúdeep changes‚Äù.

üîπ Real-time Example 1: Detecting changes inside an array
@Component({
  selector: 'app-cart',
  template: `Cart has {{ itemCount }} items`
})
export class CartComponent implements DoCheck {
  @Input() items: string[] = [];
  itemCount = 0;
  private prevLength = 0;

  ngDoCheck() {
    // Detect deep changes (push/pop)
    if (this.items.length !== this.prevLength) {
      this.prevLength = this.items.length;
      this.itemCount = this.items.length;
      console.log("Cart updated, new count:", this.itemCount);
    }
  }
}


If the parent does this.items.push("item"), Angular won‚Äôt notice by itself.

But with ngDoCheck, you can manually detect and respond.

==============================================,ngAfterContentInit 

üëâ Think of a box (ChildComponent) with an open slot (<ng-content>).
Whatever you (the parent) put inside that slot, Angular will project (insert) into the child‚Äôs template.

That inserted stuff = Content.

Your child‚Äôs own template = View.

üîπ Example without projection (normal view)
<!-- child.component.html -->
<div>
  <h2>Child View</h2>
</div>


Nothing is projected here. The child owns its own template.

üîπ Example WITH projection (using ng-content)
<!-- child.component.html -->
<div class="card">
  <h2>Child Header</h2>
  <ng-content></ng-content>   <!-- parent can insert here -->
</div>


This <ng-content> is a placeholder for whatever parent passes inside.

üîπ Parent using the child
<!-- parent.component.html -->
<app-child>
  <p>I am content coming from the parent!</p>
</app-child>


Rendered result in browser:

<div class="card">
  <h2>Child Header</h2>
  <p>I am content coming from the parent!</p> <!-- projected -->
</div>

üîπ Now where does ngAfterContentInit fit?

The child can say:

‚ÄúAfter Angular has projected the parent‚Äôs content inside me, I want to do something with it.‚Äù

So in child component:

import { Component, AfterContentInit, ContentChild, ElementRef } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `
    <div class="card">
      <h2>Child Header</h2>
      <ng-content></ng-content>  <!-- parent stuff goes here -->
    </div>
  `
})
export class ChildComponent implements AfterContentInit {
  // Get a reference to projected <p> from parent
  @ContentChild('projectedPara') para!: ElementRef;

  ngAfterContentInit() {
    console.log("üëâ ngAfterContentInit called once");
    console.log("Projected content text is:", this.para.nativeElement.textContent);
  }

  //ngAfterContentChecked starts

    ngAfterContentChecked() {
    console.log("üëâ ngAfterContentChecked called");
    console.log("Current projected content:", this.para.nativeElement.textContent);
  }

  //ngAfterContentChecked ends
}

üîπ Parent component
<app-child>
  <p #projectedPara>I am content from parent</p>
</app-child>

üîπ Console Output

When this runs:

üëâ ngAfterContentInit called
Projected content text is: I am content from parent

üîπ Key understanding

Parent puts <p> inside <app-child>.

That <p> is not the child‚Äôs own view, it‚Äôs projected content.

@ContentChild grabs it.

ngAfterContentInit fires once, right after Angular puts that content in place.

‚úÖ Super simple meaning in plain words:
ngAfterContentInit = ‚ÄúThe parent has inserted its stuff into my <ng-content>. Now I can safely look at or use it.‚Äù

==========================================================,ngAfterContentChecked


ngAfterContentInit = runs once, after content is first inserted.

ngAfterContentChecked = runs many times, after Angular re-checks that content for changes.


=====================================üîπ What is ,ngAfterViewInit?

It‚Äôs a lifecycle hook in Angular.

Called once after Angular has fully initialized the component‚Äôs own view (its template) and all child components inside it.

üëâ In simple words:

Content = what the parent puts inside your component via <ng-content>.

View = your own template + child components.

ngAfterViewInit = ‚ÄúMy own template and children are ready, now I can safely access them.‚Äù

üîπ When is it called?

After the first change detection that creates the component‚Äôs view.

Runs only once during the component‚Äôs lifetime.

üîπ Why do we use it?

To access elements in your own template using @ViewChild / @ViewChildren.

To run logic that needs the DOM available (like focusing an input, measuring size, initializing charts).

üîπ Example
Child component (child.component.ts)
import { Component, AfterViewInit, ViewChild, ElementRef } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `
    <div class="box">
      <h2>Child View</h2>
      <input #inputBox type="text" placeholder="Type here" />
    </div>
  `
})
export class ChildComponent implements AfterViewInit {
  // Access element inside THIS component's template
  @ViewChild('inputBox') inputBox!: ElementRef;

  ngAfterViewInit() {
    console.log("üëâ ngAfterViewInit called, input is ready");
    this.inputBox.nativeElement.focus(); // auto-focus input
  }
}

Parent component (parent.component.html)
<app-child></app-child>

üîπ What happens?

Angular renders <app-child>.

Inside it, the <h2> and <input> are created (child‚Äôs view).

Once view is ready ‚Üí Angular calls ngAfterViewInit.

Now the child can safely use @ViewChild to access the <input> DOM element and focus it.

üîπ Output

In console:

üëâ ngAfterViewInit called, input is ready


In browser: The input field inside <app-child> is auto-focused.

üîπ Key Points

Runs once, after view initialization.

Used with @ViewChild / @ViewChildren.

Common use cases:

Auto-focus an input.

Measure element sizes.

Initialize third-party libraries (charts, sliders, etc.).

‚úÖ In one line:
ngAfterViewInit = ‚ÄúMy own template and child components are fully ready; now I can safely interact with them.‚Äù

Would you like me to continue with ngAfterViewChecked (which is like the ‚Äúrepeat check‚Äù version of this, just like ngAfterContentChecked was for content)?

You said:
ngAfterViewChecked
ChatGPT said:

Perfect üëç let‚Äôs go step by step with ngAfterViewChecked, explained very clearly with example so even a beginner can understand.

===================================üîπ What is ,ngAfterViewChecked?

This lifecycle hook is called every time Angular checks the component‚Äôs view and all its child views.

It is like a "post-check" step after Angular makes sure everything in the view (HTML + child components) is updated.

üëâ Think of it like a teacher checking homework again and again whenever something changes in the notebook.

üîπ When is it called?

It runs after ngAfterViewInit (the first time view is ready).

Then it runs every time Angular‚Äôs change detection checks the view (for example, if a property changes, or an event triggers).

It may be called many times, not just once.

üîπ Real-time Example

Imagine you have a parent component (AppComponent) and a child component (ChildComponent).
We want to know when Angular finishes checking the child component‚Äôs view.

üìå Code Example

app.component.html

<h2>Parent Component</h2>
<button (click)="updateMessage()">Change Message</button>

<app-child [message]="parentMessage"></app-child>


app.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  parentMessage = 'Hello from Parent!';

  updateMessage() {
    this.parentMessage = 'Updated at ' + new Date().toLocaleTimeString();
  }
}


child.component.html

<h3>Child Component</h3>
<p>{{ message }}</p>


child.component.ts

import { Component, Input, AfterViewChecked } from '@angular/core';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html'
})
export class ChildComponent implements AfterViewChecked {
  @Input() message!: string;

  ngAfterViewChecked() {
    console.log('ngAfterViewChecked called in ChildComponent');
  }
}

üìå What Happens

First load ‚Üí ngAfterViewInit runs once, then ngAfterViewChecked runs.

Every time you click "Change Message", the view changes ‚Üí Angular re-checks ‚Üí ngAfterViewChecked runs again.

So this hook is useful if you want to run some logic every time view update finishes.

üîπ When do we use ngAfterViewChecked in real projects?

Rarely! Because it runs too often (every change detection cycle).

But it is useful when:

You need to run custom logic after every update of the view.

Example: logging performance, auto-scrolling chat windows after new message, syncing DOM changes that Angular doesn‚Äôt handle.

‚ö†Ô∏è Warning: Avoid heavy logic here (like API calls, complex loops), because it runs many times and can slow down your app.

‚úÖ Simple Analogy:

ngAfterViewInit = "The shop is open for the first time."

ngAfterViewChecked = "The shopkeeper checks the shop every time a customer comes in or something changes."

====================================================




===========================================What is a ,dataBinding?======================================

Data binding is a core concept in Angular and allows to define communication between a component and the DOM/view, making it very easy to define interactive applications 
without worrying about pushing and pulling data. 
There are four forms of data binding(divided as 3 categories) which differ in the way the data is flowing.

Data binding is a technique, where the data stays in sync between the component and the view. Whenever the user updates the data in the view, Angular updates the component. When the component gets new data, the Angular updates the view.

There are many uses of data binding. You can show models to the user, dynamically Change element style, respond to user events, etc

 -------------1:-From the Component to the DOM:

  a:Interpolation: 
  
  {{ value }}: Adds the value of a property from the component

<li>Name: {{ user.name }}</li>
<li>Address: {{ user.address }}</li>

  b:Property binding: 

  [property]=‚Äùvalue‚Äù: The value is passed from the component to the specified property or simple HTML attribute

<input type="email" [value]="user.email">
------------2:-From the DOM to the Component: 

Event binding: (event)=‚Äùfunction‚Äù: When a specific DOM event happens (eg.: click, change, keyup), call the specified method in the component

<button (click)="logout()"></button>

------------3:-Two-way binding: Two-way data binding: 

[(ngModel)]=‚Äùvalue‚Äù: Two-way data binding allows to have the data flow both ways. For example, in the below code snippet, both the email DOM input and component email property are in sync

<input type="email" [(ngModel)]="user.email">



=========================What is ,metadata?

Metadata is used to decorate a class so that it can configure the expected behavior of the class. The metadata is represented by decorators

Class decorators, e.g. @Component and @NgModule
import { NgModule, Component } from '@angular/core';

@Component({
  selector: 'my-component',
  template: '<div>Class decorator</div>',
})
export class MyComponent {
  constructor() {
    console.log('Hey I am a component!');
  }
}

@NgModule({
  imports: [],
  declarations: [],
})
export class MyModule {
  constructor() {
    console.log('Hey I am a module!');
  }
}

Property decorators Used for properties inside classes, e.g. @Input and @Output
import { Component, Input } from '@angular/core';

@Component({
    selector: 'my-component',
    template: '<div>Property decorator</div>'
})

export class MyComponent {
    @Input()
    title: string;
}

Method decorators Used for methods inside classes, e.g. @HostListener
import { Component, HostListener } from '@angular/core';

@Component({
    selector: 'my-component',
    template: '<div>Method decorator</div>'
})
export class MyComponent {
    @HostListener('click', ['$event'])
    onHostClick(event: Event) {
        // clicked, `event` available
    }
}

Parameter decorators Used for parameters inside class constructors, e.g. @Inject, Optional
import { Component, Inject } from '@angular/core';
import { MyService } from './my-service';

@Component({
    selector: 'my-component',
    template: '<div>Parameter decorator</div>'
})
export class MyComponent {
    constructor(@Inject(MyService) myService) {
        console.log(myService); // MyService
    }
}





============================What is ,angularCLI?(,cli)
Angular CLI(Command Line Interface) is a command line interface to scaffold and build angular apps using nodejs style (commonJs) modules. 
You need to install using below npm command,
npm install @angular/cli@latest
Below are the list of few commands, which will come handy while creating angular projects
Creating New Project: ng new

Generating Components, Directives & Services: ng generate/g The different types of commands would be,

ng generate class my-new-class: add a class to your application
ng generate component my-new-component: add a component to your application
ng generate directive my-new-directive: add a directive to your application
ng generate enum my-new-enum: add an enum to your application
ng generate module my-new-module: add a module to your application
ng generate pipe my-new-pipe: add a pipe to your application
ng generate service my-new-service: add a service to your application

Running the Project: ng serve



====================constructor ,vs ngOnint ===============================

Constructor:

The constructor is a special method that gets called when an object of a class is created.
It's used for basic setup, initializing variables, and preparing the object.
It's not specific to Angular; it's a fundamental part of object-oriented programming.
ngOnInit:

ngOnInit is a lifecycle hook in Angular specifically designed for components.
It is called after the constructor when Angular has initialized the component and is about to display it.
It's the recommended place for more advanced initialization, fetching data, or performing actions that involve Angular features.

Use the Constructor When:
Basic Initialization:

Use the constructor for basic setup, initializing variables, and setting up the initial state of the component.
Dependency Injection:

If your component needs services or dependencies injected, set them up in the constructor. Angular automatically injects dependencies when creating an instance of the component.
Avoid Complex Logic:

Keep the constructor simple and avoid complex logic that might involve asynchronous operations. The constructor should focus on immediate setup.


Use ngOnInit When:
Advanced Initialization:

Use ngOnInit for more advanced initialization, especially when you need to perform tasks that involve Angular features, such as interacting with the Angular lifecycle, accessing input properties, or fetching data.
Async Operations:

If your initialization tasks involve asynchronous operations like fetching data from a server, ngOnInit is a better choice. Angular guarantees that it won't be called until after the component is fully constructed.
Interaction with Angular Lifecycle:

If you need to interact with the Angular lifecycle hooks, ngOnInit is a safe place to do so. It ensures that the component is fully initialized and ready to interact with other components.


export class ExampleComponent implements OnInit {
  // Input property
  @Input() data: any;

  // Constructor for basic setup
  constructor(private dataService: DataService) {
    // Basic setup
    this.message = 'Hello, Angular!';
  }

  // ngOnInit for advanced initialization
  ngOnInit(): void {
    // Advanced initialization
    this.loadData();
  }

  private loadData(): void {
    // Fetch data from a service
    this.dataService.getData().subscribe((result) => {
      this.data = result;
    });
  }
}


==== Why constructor is called before ngOnInit?
This is because the constructor is called to initialize the class and not the component. The constructor is called before ngOnInit , 
at this point the component hasn't been created yet, only the component class has being instantiated thus your dependencies are brought in, 
but your initialization code will not run.



=================================What is a ,service?

Services allow us to create reusable code and use it every component that needs it. 
The Services can be injected into components and other services using the dependency injection system.
 The dependencies are declared in the Module using the Provider‚Äôs metadata. The Angular creates a tree of injector & Providers that resembles the Component Tree.
  This is called the hierarchical pattern.

A service is used when a common functionality needs to be provided to various modules. 
Services allow for greater separation of concerns for your application and better modularity by allowing you to extract common functionality out of components.


===================================What is dependency injection in Angular?(,dependencyInjection)

Dependency injection (DI), is an important application design pattern in which a class asks for dependencies from external sources rather than creating them itself. 
Angular comes with its own dependency injection framework for resolving dependencies( services or objects that a class needs to perform its function).
So you can have your services depend on other services throughout your application



==================================What is the option to choose between ,inline ,vs+ external template file?=================

You can store your component's template in one of two places. You can define it inline using the template property, or you can define the template in a separate HTML 
file and link to it in the component metadata using the @Component decorator's templateUrl property.

The choice between inline and separate HTML is a matter of taste, circumstances, and organization policy. 
But normally we use inline template for small portion of code and external template file for bigger views. 
By default, the Angular CLI generates components with a template file. But you can override that with the below command,

ng generate component hero -it




======================================What happens if you use script tag inside template?(,scriptTag)===========================
Angular recognizes the value as unsafe and automatically sanitizes it, which removes the script tag but keeps safe content such as the text content of the script tag.
 This way it eliminates the risk of script injection attacks. If you still use it then it will be ignored and a warning appears in the browser console.

Let's take an example of innerHtml property binding which causes XSS vulnerability,

export class InnerHtmlBindingComponent {
  // For example, a user/attacker-controlled value from a URL.
  htmlSnippet = 'Template <script>alert("0wned")</script> <b>Syntax</b>';
}


==========================================What is ,interpolation?==========================

Interpolation is a special syntax that Angular converts into property binding. It‚Äôs a convenient alternative to property binding. 
It is represented by double curly braces({{}}). 
The text between the braces is often the name of a component property. Angular replaces that name with the string value of the corresponding component property.

Let's take an example,

<h3>
  {{title}}
  <img src="{{url}}" style="height:30px">
</h3>


==========================================What are template expressions? (,templateExpression)======================================

A template expression produces a value similar to any Javascript expression. 
Angular executes the expression and assigns it to a property of a binding target; 
the target might be an HTML element, a component, or a directive. 
In the property binding, a template expression appears in quotes to the right of the = symbol as in [property]="expression". 
In interpolation syntax, the template expression is surrounded by double curly braces. 
For example, in the below interpolation, the template expression is {{username}},

<h3>{{username}}, welcome to Angular</h3>
The below javascript expressions are prohibited in template expression

assignments (=, +=, -=, ...)
new
chaining expressions with ; or ,
increment and decrement operators (++ and --)



======================================================What are ,templateStatements?
A template statement responds to an event raised by a binding target such as an element, component, or directive. 
The template statements appear in quotes to the right of the = symbol like (event)="statement".

Let's take an example of button click event's statement

<button (click)="editProfile()">Edit Profile</button>
In the above expression, editProfile is a template statement. The below JavaScript syntax expressions are not allowed.

new
increment and decrement operators, ++ and --
operator assignment, such as += and -=
the bitwise operators | and &
the template expression operators



==================== What are ,filters,pipe in Angular? Name a few of them.======
Filters are used to format an expression and present it to the user. They can be used in view templates, controllers, or services. Some inbuilt filters are as follows. 

date - Format a date to a specified format.
filter - Select a subset of items from an array.
Json - Format an object to a JSON string.
limitTo -  Limits an array/string, into a specified number of elements/characters.
lowercase - Format a string to lowercase.



==========================================What are ,pipes?
The Angular pipes are used to Transform the Data.
A pipe takes in data as input and transforms it to a desired output. 
 We use them to change the appearance of the data before presenting it to the user.
  --built in pipes :-
  angular built-in pipes like 
               currency pipe, 
               date pipe, 
               number pipe, 
               percent pipe, 
               decimal pipe, & 
               slice pipe etc.

  syntax:
Expression | pipeOperator[:pipeArguments]


  Expression: is the expression, which you want to transform
  | : is the Pipe Character
  pipeOperator : name of the Pipe
  pipeArguments: arguments to the Pipe


For example, let us take a pipe to transform a component's birthday property into a human-friendly date using date pipe.

import { Component } from '@angular/core';

@Component({
  selector: 'app-birthday',
  template: `<p>Birthday is {{ birthday | date }}</p>`
})
export class BirthdayComponent {
  birthday = new Date(1987, 6, 18); // June 18, 1987
}



===========================================What is a parameterized Pipe? (,parameterizedPipe)====================

A pipe can accept any number of optional parameters to fine-tune its output. 
The parameterized pipe can be created by declaring the pipe name with a colon ( : ) and then the parameter value. 
If the pipe accepts multiple parameters, separate the values with colons. Let's take a birthday example with a particular format(dd/MM/yyyy):

import { Component } from '@angular/core';

    @Component({
      selector: 'app-birthday',
      template: `<p>Birthday is {{ birthday | date:'dd/MM/yyyy'}}</p>` // 18/06/1987
    })
    export class BirthdayComponent {
      birthday = new Date(1987, 6, 18);
    }
Note: The parameter value can be any valid template expression, such as a string literal or a component property.



============================================How do you ,chainPipes?======================

You can chain pipes together in potentially useful combinations as per the needs. 
Let's take a birthday property which uses date pipe(along with parameter) and uppercase pipes as below

import { Component } from '@angular/core';

        @Component({
          selector: 'app-birthday',
          template: `<p>Birthday is {{  birthday | date:'fullDate' | uppercase}} </p>` // THURSDAY, JUNE 18, 1987
        })
        export class BirthdayComponent {
          birthday = new Date(1987, 6, 18);
        }



EXAMPLES:
Imagine you have a string with a date in a specific format, and you want to display it in a more readable and localized way. You might need to:

Parse the date string.
Format the date.
Convert it to uppercase.
Chaining pipes helps you apply each transformation step by step.

 <div *ngFor="let post of posts">
      {{ post.title }} - Created on: {{ post.createdAt | date:'medium' | uppercase }}
    </div>


    


============================================What is a ,customPipe?================================

Apart from built-inn pipes, you can write your own custom pipe with the below key characteristics,
A pipe is a class decorated with pipe metadata @Pipe decorator, which you import from the core Angular library For example,
    @Pipe({name: 'myCustomPipe'})
The pipe class implements the PipeTransform interface's transform method that accepts an input value followed by optional parameters and returns the transformed value. The structure of pipeTransform would be as below,
interface PipeTransform {
  transform(value: any, ...args: any[]): any
}
The @Pipe decorator allows you to define the pipe name that you'll use within template expressions. It must be a valid JavaScript identifier.
template: `{{someInputValue | myCustomPipe: someOtherValue}}`




==============================================What is the difference between ,pure ,vs ,impure pipe?


A pure pipe is only called when Angular detects a change in the value or the parameters passed to a pipe. 
For example, any changes to a primitive input value (String, Number, Boolean, Symbol) or a changed object reference (Date, Array, Function, Object). 
Pure Pipe Example:
Suppose you have a list of names, and you want to display these names in uppercase. The names are static and don't change during the lifetime of the component.
 It transforms the static input (names) into uppercase, and since the names don't change


An impure pipe is called for every change detection cycle no matter whether the value or parameters changes. 
i.e, An impure pipe is called often, as often as every keystroke or mouse-move.
Impure Pipe Example:
Now, consider a scenario where you have a list of messages, and you want to display each message along with the current time it was viewed. The time is dynamic and should update in real-time


=======================================What is the purpose of ,asyncPipe?============

The AsyncPipe subscribes to an observable or promise and returns the latest value it has emitted. 
When a new value is emitted, the pipe marks the component to be checked for changes.

Let's take a time observable which continuously updates the view for every 2 seconds with the current time.

@Component({
  selector: 'async-observable-pipe',
  template: `<div><code>observable|async</code>:
       Time: {{ time | async }}</div>`
})
export class AsyncObservablePipeComponent {
  time = new Observable(observer =>
    setInterval(() => observer.next(new Date().toString()), 2000)
  );
}

===============================================What is a ,bootstrappingModule?==============

Every application has at least one Angular module, the root module that you bootstrap to launch the application is called as bootstrapping module. 
It is commonly known as AppModule. The default structure of AppModule generated by AngularCLI would be as follows,

```javascript
/* JavaScript imports */
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';

import { AppComponent } from './app.component';

/* the AppModule class with the @NgModule decorator */
@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpClientModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }


(or))


Bootstrapping a module in the context of an Angular application refers to the process of launching and initializing the Angular framework for your application. It involves setting up the necessary infrastructure to run your Angular code, starting from a designated module.

In simpler terms:

Module Definition:

In Angular, your application is organized into modules. A module is a way to group related components, services, and other features of your application.
Root Module:

Every Angular application has a root module, which is the entry point of your application. This module is typically named AppModule.
Bootstrapping:

Bootstrapping is the act of telling Angular to start the application by loading and initializing the root module.
Bootstrap Module:

The term "bootstrap module" usually refers to the root module of your Angular application. It's the module that gets bootstrapped to start the entire application.
Main Entry Point:

In your Angular project, there's a file called main.ts. This file serves as the main entry point for your application, and its purpose is to bootstrap the root module.
So, in essence, bootstrapping a module in Angular means starting your application by initializing the root module, and this process is kicked off from the main.ts file. The root module defines the structure and dependencies of your application, and bootstrapping is the trigger that gets everything up and running.



======================================What is a bootstrapped component?(,bootstrappedComponent)
A bootstrapped component is an entry component that Angular loads into the DOM during the bootstrap process or application launch time. 
Generally, this bootstrapped or root component is named as AppComponent in your root module using bootstrap property as below.

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpClientModule,
    AppRoutingModule
  ],
  providers: [],
  bootstrap: [AppComponent] // bootstrapped entry component need to be declared here
})


=========================================difference between ,promise,vs,observable?  or   ,observables,vs,promise

Below are the list of differences between promise and observable,

                                Observable	                                                                                       Promise

Declarative: Computation does not start until subscription so that they can be run whenever you need the result	         Execute immediately on creation
Provide multiple values over time	                                                                                       Provide only one
Subscribe method is used for error handling which makes centralized and predictable error handling	                     Push errors to the child promises
Provides chaining and subscription to handle complex applications	                                                       Uses only .then() clause


=================================================What is ,multicasting?

Multi-casting is the practice of broadcasting to a list of multiple subscribers in a single execution.

Let's demonstrate the multi-casting feature,

var source = Rx.Observable.from([1, 2, 3]);
var subject = new Rx.Subject();
var multicasted = source.multicast(subject);

// These are, under the hood, `subject.subscribe({...})`:
multicasted.subscribe({
  next: (v) => console.log('observerA: ' + v)
});
multicasted.subscribe({
  next: (v) => console.log('observerB: ' + v)
});

// This is, under the hood, `s



=========================================How can you read full response?(,fullResponse)

The response body doesn't may not return full response data because sometimes servers also return special headers or status code which which are important for the 
   application workflow. 
Inorder to get full response, you should use observe option from HttpClient,

getUserResponse(): Observable<HttpResponse<User>> {
  return this.http.get<User>(
    this.userUrl, { observe: 'response' });
}
Now HttpClient.get() method returns an Observable of typed HttpResponse rather than just the JSON data.



============================================What are ,observables?============================

Observables are declarative which provide support for passing messages between publishers and subscribers in your application. 
They are mainly used for event handling, asynchronous programming, and handling multiple values. 
In this case, you define a function for publishing values, but it is not executed until a consumer subscribes to it. 
The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.



=========================================observable?

An Observable is a unique Object similar to a Promise that can help manage async code. 
Observables are not part of the JavaScript language so we need to rely on a popular Observable library called RxJS. 
The observables are created using new keyword.

Let see the simple example of observable,

import { Observable } from 'rxjs';

const observable = new Observable(observer => {
  setTimeout(() => {
    observer.next('Hello from a Observable!');
  }, 2000);
});

===========================================What is an ,observer?

Observer is an interface for a consumer of push-based notifications delivered by an Observable. It has below structure,

interface Observer<T> {
  closed?: boolean;
  next: (value: T) => void;
  error: (err: any) => void;
  complete: () => void;
}
A handler that implements the Observer interface for receiving observable notifications will be passed as a parameter for observable as below,

myObservable.subscribe(myObserver);
Note: If you don't supply a handler for a notification type, the observer ignores notifications of that type.



=======================================How do you perform Error handling?(,errorHandling)

If the request fails on the server or failed to reach the server due to network issues then HttpClient will return an error object instead of a successful reponse. 
In this case, you need to handle in the component by passing error object as a second callback to subscribe() method.

Let's see how it can be handled in the component with an example,

fetchUser() {
  this.userService.getProfile()
    .subscribe(
      (data: User) => this.userProfile = { ...data }, // success path
      error => this.error = error // error path
    );
}
It is always a good idea to give the user some meaningful feedback instead of displaying the raw error object returned from HttpClient.


========================================How do you perform error handling in observables?(,errorHandlingInObservables)

You can handle errors by specifying an error callback on the observer instead of relying on try/catch which are ineffective in asynchronous environment.

For example, you can define error callback as below,

myObservable.subscribe({
  next(num) { console.log('Next num: ' + num)},
  error(err) { console.log('Received an errror: ' + err)}
});


===============================================What is ,HttpClient and its benefits?=====================
Most of the Front-end applications communicate with backend services over HTTP protocol using either XMLHttpRequest interface or the fetch() API. 
Angular provides a simplified client HTTP API known as HttpClient which is based on top of XMLHttpRequest interface. 

HttpClient is a built-in service class available in the @angular/common/http package. 
It has multiple signature and return types for each request. 
It uses the RxJS observable-based APIs, which means it returns the observable and what we need to subscribe it.


ex:-reference link=https://www.telerik.com/blogs/angular-basics-how-to-use-httpclient#:~:text=What%20Is%20HttpClient%3F,we%20need%20to%20subscribe%20it.
steps:
 1. Import or configure the HttpClientModule into the app.module.ts file 
 2. You can directly use the HttpClient in your component, but its best to access it via the service.
 3. Inject the HttpClient in the service file 
 4.In this step we are going to fetch the data from the server with the help of HTTP GET request.
 5.


This client is avaialble from @angular/common/http package. You can import in your root module as below,

import { HttpClientModule } from '@angular/common/http';
The major advantages of HttpClient can be listed as below,

Contains testability features
Provides typed request and response objects
Intercept request and response
Supports Observalbe APIs
Supports streamlined error handling



=================================================Explain on how to use ,HttpClient with an example?============================

Below are the steps need to be followed for the usage of HttpClient.
1.Import HttpClient into root module:

import { HttpClientModule } from '@angular/common/http';
@NgModule({
  imports: [
    BrowserModule,
    // import HttpClientModule after BrowserModule.
    HttpClientModule,
  ],
  ......
  })
 export class AppModule {}
2.Inject the HttpClient into the application: Let's create a userProfileService(userprofile.service.ts) as an example. It also defines get method of HttpClient

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';

const userProfileUrl: string = 'assets/data/profile.json';

@Injectable()
export class UserProfileService {
  constructor(private http: HttpClient) { }

  getUserProfile() {
    return this.http.get(this.userProfileUrl);
  }
}
3.Create a component for subscribing service:
Let's create a component called UserProfileComponent(userprofile.component.ts) which inject UserProfileService and invokes the service method,

fetchUserProfile() {
  this.userProfileService.getUserProfile()
    .subscribe((data: User) => this.user = {
        id: data['userId'],
        name: data['firstName'],
        city:  data['city']
    });
}
Since the above service method returns an Observable which needs to be subscribed in the component.




38  pending


==================================================What is RxJS?    (,rxjs)================================

RxJS is a library for composing asynchronous and callback-based code in a functional, reactive style using Observables. 
Many APIs such as HttpClient produce and consume RxJS Observables and also uses operators for processing observables.

For example, you can import observables and operators for using HttpClient as below,

import { Observable, throwError } from 'rxjs';
import { catchError, retry } from 'rxjs/operators';


==================================================What is ,subscribing?===========================
An Observable instance begins publishing values only when someone subscribes to it. 
So you need to subscribe by calling the subscribe() method of the instance, passing an observer object to receive the notifications.

Let's take an example of creating and subscribing to a simple observable, with an observer that logs the received message to the console.



==================================,subscribeMethod?

The subscribe() method can accept callback function definitions in line, for next, error, and complete handlers is known as short hand notation or Subscribe method with positional arguments.

For example, you can define subscribe method as below,

myObservable.subscribe(
  x => console.log('Observer got a next value: ' + x),
  err => console.error('Observer got an error: ' + err),
  () => console.log('Observer got a complete notification')
);



================================================What is an ,observable?===============================================
An Observable is a unique Object similar to a Promise that can help manage async code. 
Observables are not part of the JavaScript language so we need to rely on a popular Observable library called RxJS. 
The observables are created using new keyword


===============================================What are ,dynamicComponents?===========================================

Dynamic components are the components in which components location in the application is not defined at build time.i.e, 
They are not used in any angular template. But the component is instantiated and placed in the application at runtime.


===================================================What is Angular ,router?

The Router module handles the navigation & Routing in Angular. 
The Routing allows you to move from one part of the application to another part or one View to another View.
It is in its own library package, @angular/router.

Angular Router is a mechanism in which navigation happens from one view to the next as users perform application tasks. 
It borrows the concepts or model of browser's application navigation

Using Angular Router you can
  Navigate to a specific view by typing a URL in the address bar
  Pass optional parameters to the View
  Bind the clickable elements to the View and load the view when the user performs application tasks
  Handles back and forward buttons of the browser
  Allows you to dynamically load the view
  Protect the routes from unauthorized users using Guards


  *To Configure the Router in Angular, you need to follow these steps
    Set the <base href>                               
    ex:-
      <base href="/">
    Define routes for the view                        
    ex:-
      const appRoutes={ path: 'product', component: ProductComponent },
                        { path: '', redirectTo: 'home', pathMatch: 'full' },   //defaulot route
                        { path: '**', component: ErrorComponent }              //wildcard route 
    Register the Router Service with Routes 
      ex:-
        import { RouterModule } from '@angular/router';
        import { routes } from './app.routes'; 

        imports: [RouterModule.forRoot(routes)],    /*path location strategy */
                /*RouterModule.forRoot(appRoutes, { useHash: true }) */   /*Hashlocationstrategy */
    Map HTML Element actions to Route
      ex:-
        <li><a [routerLink]="['product']">Product</a></li>
    Choose where you want to display the view
     ex:-
       <router-outlet></router-outlet>



 ========================================,components of angularRouterModule
Router:-
    The Angular Router is an object that enables navigation from one component to the next component as users perform application tasks like clicking on menus links, 
        buttons or clicking on back/forward button on the browser. 
    We can access the router object and use its methods like navigate() or navigateByUrl(), to navigate to a route

Route:-
    Route tells the Angular Router which view to display when a user clicks a link or pastes a URL into the browser address bar. 
    Every Route consists of a path and a component it is mapped to. 
    The Router object parses and builds the final URL using the Route

Routes:-
    Routes is an array of Route objects our application supports

RouterOutlet:-
    The outerOutlet is a directive (<router-outlet>) that serves as a placeholder, where the Router should display the view

RouterLink:-
    The RouterLink is a directive that binds the HTML element to a Route. 
    Clicking on the HTML element, which is bound to a RouterLink, will result in navigation to the Route. 
    The RouterLink may contain parameters to be passed to the route‚Äôs component.

RouterLinkActive:-
    RouterLinkActive is a directive for adding or removing classes from an HTML element that is bound to a RouterLink. 
    Using this directive, we can toggle CSS classes for active RouterLinks based on the current RouterState

ActivatedRoute:-
    The ActivatedRoute is an object that represents the currently activated route associated with the loaded Component.

RouterState:-
    The current state of the router including a tree of the currently activated routes together with convenience methods for traversing the route tree.

RouteLink Parameters array:-
    The Parameters or arguments to the Route. 
    It is an array which you can bind to RouterLink directive or pass it as an argument to the Router.navigate method.      


===================================================What is the purpose of ,Wildcard route?=========================================

If the URL doesn't match any predefined routes then it causes the router to throw an error and crash the app. 
In this case, you can use wildcard route. A wildcard route has a path consisting of two asterisks to match every URL.

For example, you can define PageNotFoundComponent for wildcard route as below

{ path: '**', component: PageNotFoundComponent }



==============================,AJAX?(,ajax)

Angular uses AJAX technology to build single-page applications
When we use HttpClient for the Ajax calls in Angular Framework, 
       we can use both implementations (i.e. observables or promises) which provides an easy way of API operation for handling requests or receiving a response.


=======================================================What is Angular Universal?  (,angularUniversal)(,universal)
Angular Universal is a server-side rendering module for Angular applications in various scenarios. 
This is a community driven project and available under @angular/platform-server package. Recently Angular Universal is integrated with Angular CLI.


========================================================What are different types of compilation in Angular?
Angular offers two ways to compile your application,
Just-in-Time (JIT)
Ahead-of-Time (AOT)

============== What is the difference between AOT and JIT?(,Aot ,vs ,git) =========
Ahead of Time (AOT) compilation converts your code during the build time before the browser downloads and runs that code. This ensures faster rendering to the browser. To specify AOT compilation, include the --aot option with the ng build or ng serve command. 

The Just-in-Time (JIT) compilation process is a way of compiling computer code to machine code during execution or run time. It is also known as dynamic compilation. JIT compilation is the default when you run the ng build or ng serve CLI commands. 



==============================What is JIT?(,jit)
Just-in-Time (JIT) is a type of compilation that compiles your app in the browser at runtime. 
JIT compilation is the default when you run the ng build (build only) or 
ng serve (build and serve locally) CLI commands. i.e, the below commands used for JIT compilation,

ng build
ng serve


=================================What is AOT?  (,aot)
Ahead-of-Time (AOT) is a type of compilation that compiles your app at build time. 
For AOT compilation, include the --aot option with the ng build or ng serve command as below,

ng build --aot
ng serve --aot

Note: The ng build command with the --prod meta-flag (ng build --prod) compiles with AOT by default


or

The Ahead-of-time (AOT) compiler converts the Angular HTML and TypeScript code into JavaScript code during the build phase, i.e., before the browser downloads and runs the code.

Some of its advantages are as follows. 

Faster rendering
Fewer asynchronous requests
Smaller Angular framework download size
Quick detection of template errors
Better security



===================================Why do we need ,compilation process?===============================
The Angular components and templates cannot be understood by the browser directly. 
Due to that Angular applications require a compilation process before they can run in a browser. 
For example, In AOT compilation, both Angular HTML and TypeScript code converted into efficient JavaScript code during the build phase before browser runs it.



===================================How do you find angular CLI ,version?==================================
Angular CLI provides it's installed version using below different ways using ng command,

ng v
ng version
ng -v
ng --version
and the output would be as below,

Angular CLI: 1.6.3
Node: 8.11.3
OS: darwin x64
Angular:
...





=============================What is validator in Angular?(,validator)===================

A validator is a function that processes a FormControl or collection of controls and returns an error map or null. 
A null map means that validation has passed.



====================================What are the types of validator functions?(,validatorFunction ,types)
In reactive forms, the validators can be either synchronous or asynchronous functions,

Sync validators: These are the synchronous functions which take a control instance and immediately return either a set of validation errors or null. 
                Also, these functions passed as second argument while instantiating the form control. 
                The main use cases are simple checks like whether a field is empty, whether it exceeds a maximum length etc.
Async validators: These are the asynchronous functions which take a control instance and return a Promise or Observable that later emits a set of validation errors 
                  or null. 
                  Also, these functions passed as second argument while instantiating the form control. 
                  The main use cases are complex validations like hitting a server to check the availability of a username or email.





====================================How do you ,reset the form?

In a model-driven form, you can reset the form just by calling the function reset() on our form model. 
For example, you can reset the form model on submission as follows,

onSubmit() {
  if (this.myform.valid) {
    console.log("Form is submitted");
    // Perform business logic here
    this.myform.reset();
  }
}




================================================What are the ,stateCSSclasses provided by ,ngModel?

The ngModel directive updates the form control with special Angular CSS classes to reflect it's state. Let's find the list of classes in a tabular format,

Form control state	                          If true	                     If false
Visited	                                    ng-touched	                 ng-untouched
Value has changed	                          ng-dirty	                   ng-pristine
Value is valid	                            ng-valid	                   ng-invalid







==============================How to set ngFor and ngIf on the same element?======================

Sometimes you may need to both ngFor and ngIf on the same element but unfortunately you are going to encounter below template error.

 Template parse errors: Can't have multiple template bindings on one element.

In this case, You need to use either ng-container or ng-template.
 Let's say if you try to loop over the items only when the items are available, the below code throws an error in the browser

<ul *ngIf="items" *ngFor="let item of items">
  <li></li>
</ul>
and it can be fixed by

<ng-container *ngIf="items">
  <ul *ngFor="let item of items">
    <li></li>
  </ul>
</ng-container>


======================================How do you get the current route?===============(,currentRoute)
In Angular, there is an url property of router package to get the current route. You need to follow the below few steps,

1.Import Router from @angular/router
  import { Router } from '@angular/router';
2.Inject router inside constructor
  constructor(private router: Router ) {
  }
3.Access url parameter
  console.log(this.router.url); //  /routename



=========================================================What is the benefit of Automatic Inlining of Fonts?(,automaticInlining)
During compile time, Angular CLI will download and inline the fonts that your application is using. 
This performance update speed up the first contentful paint(FCP) and this feature is enabled by default in apps built with version 11.


==================================================What is content projection?================(,contentProjection)
Content projection is a pattern in which you insert, or project, the content you want to use inside another component.

===================================================What is ng-content and its purpose?  (,ngContent)
The ng-content is used to insert the content dynamically inside the component that helps to increase component reusability.
 
 ----><ng-container></ng-container>
ng-container is an extremely simple directive that allows you to group elements in a template that doesn‚Äôt interfere with styles or layout because Angular doesn‚Äôt 
put it in the DOM

This is helpful if you don‚Äôt want any extra div on DOM, you can simply use
ng-container. For eg: If there are two structural directives are being called on one div as below:

<div *ngIf="details" *ngFor="let info of details">
  {{ info.content }}
</div>
Attempting to compile this code will result in the following error:

Can't have multiple template bindings on one element. Use only one attribute prefixed with *
One workaround would be to separate the bindings as below:

<div *ngIf="details">
  <div *ngFor="let info of details">
    {{ info.content }}
  </div>
</div>
Or we can use <ng-container> without adding any extra element to the DOM at runtime:

<ng-container *ngIf="details">
  <div *ngFor="let info of details">
    {{ info.content }}
  </div>
</ng-container>
3) <ng-content></ng-content>
ng-content is used to project content into Angular components. You use the <ng-content></ng-content> tag as a placeholder for that dynamic content, 
then when the template is parsed Angular will replace that placeholder tag with your content.

For example, you have two components as parent and child component
and want to show some data in the child component from the parent component

In parent.component.html <app-child> selector is used to show data of child component

<app-child>
  <div> Child Component Details </div>
</app-child>
If you check on your browser <div>Child Component Details</div> inside
<app-child></app-child> would not be visible. What if we want to show this content? So this is where the ng-content directive comes into the picture. 
What we need to do is, just add ‚Äúng-content‚Äù inside the component template and it will find the content inside the directive tag and add it to that template at 
that particular place where we added the ‚Äúng-content‚Äù tag.

So instead of div, you do something similar with Angular components except if you tell Angular where to display it in the parent template using ng-content.

In child.component.html:

<h1>Child Info</h1>
<ng-content></ng-content>
Now go to your browser again, you are able to see this: <div>Child Component Details</div>

<ng-content> accepts a select attribute, which allows us to sort of name our slot, to be more specific, it allows us to define the selector of our slot. 
It means ‚ÄúReplace me only if the element has card-body attribute‚Äù. Then, we change our app component view to include the card-body attribute.

For example: In child.component.html:

<h1>Child Info</h1>
<ng-content select="[input], [form-field]"></ng-content>
In parent.component.html:

<app-child>
  <h1 input>Content1!</h3>
  <h2 form-field>Content2!</h2>
  <h3 input form-field>Content1 & Content2!</h1>
</app-child>
If you check your browser, all the heading tags will be visible from child component with the help of <ng-content>.

To sum up, ng-content is used to display children in a template, ng-container is used as a non-rendered container to avoid having to add a span or a div, 
and ng-template allows you to group some content that is not rendered directly but can be used in other places of your template or you code.

=======================================,ngTemplate==============================

      <ng-template></ng-template>
As the name suggests the <ng-template> is a template element that Angular uses with structural directives ( *ngIf , *ngFor , [ngSwitch] and custom directives). 
These template elements only work in the presence of structural directives, which help us to define a template that doesn‚Äôt render anything by itself, 
                       but conditionally renders them to the DOM. 
It helps us create dynamic templates that can be customized and configured.

<div> 
   Ng-template Content 
   <div *ngIf=‚Äùfalse else showNgTemplateContent‚Äù> 
      Shouldn't be displayed 
   </div>
</div>
 
<ng-template #showNgTemplateContent> Should be displayed
</ng-template>


================================================,ngContainer======================================================
 <ng-container></ng-container>
ng-container is an extremely simple directive that allows you to group elements in a template that doesn‚Äôt interfere with styles or layout because 
                   Angular doesn‚Äôt put it in the DOM

This is helpful if you don‚Äôt want any extra div on DOM, you can simply use
ng-container. For eg: If there are two structural directives are being called on one div as below:

<div *ngIf="details" *ngFor="let info of details">
  {{ info.content }}
</div>
Attempting to compile this code will result in the following error:

Can't have multiple template bindings on one element. Use only one attribute prefixed with *
One workaround would be to separate the bindings as below:

<div *ngIf="details">
  <div *ngFor="let info of details">
    {{ info.content }}
  </div>
</div>
Or we can use <ng-container> without adding any extra element to the DOM at runtime:

<ng-container *ngIf="details">
  <div *ngFor="let info of details">
    {{ info.content }}
  </div>
</ng-container>




=====================================types of injector hierarchies?

There are two types of injector hierarchies in Angular

ModuleInjector hierarchy: It configure on a module level using an @NgModule() or @Injectable() annotation.
ElementInjector hierarchy: It created implicitly at each DOM element. 
Also it is empty by default unless you configure it in the providers property on @Directive() or @Component().





==================================================The Template-driven forms (,templateDrivenForms)

The form is set up using ngForm directive
controls are set up using the ngModel directive
ngModel also provides the two-way data binding
The Validations are configured in the template via directives

To work with Template-driven forms, 
    1.we must import the FormsModule. We usually import it in root module or in a shared module.
    2.create regular html form in form tag
    3.using ngForm directive ,normal form converted into template driven forms
          ex:-<form #contactForm="ngForm">
              <input type="text" name="firstname" ngModel>
              <form #contactForm="ngForm" (ngSubmit)="onSubmit(contactForm)">
               onSubmit(contactForm) {
                    console.log(contactForm.value);
                       }


        ----------The ,ngForm does the following

Binds itself to the <Form> directive
Creates a top-level FormGroup instance
CreatesFormControl instance for each of child control, which has ngModel directive.
CreatesFormGroup instance for each of the  NgModelGroup directive.


================================================What are Reactive Forms? (,reactiveForms)
also known as MOdel driven forms 
Reactive forms are forms where we define the structure of the form in the component class. i.e. 
we create the form model with Form Groups, Form Controls, and FormArrays. We also define the validation rules in the component class. 
Then, we bind it to the HTML form in the template. 

This is different from the template-driven forms, where we define the logic and controls in the HTML template.

    How to use Reactive Forms
Import ReactiveFormsModule  in root Module 
Create Form Model in component class using FormGroup, FormControl & FormArrays
Create the HTML Form resembling the Form Model.
Bind the HTML Form to the Form Model

  ex:-<form [formGroup]="contactForm">
      <input type="text" id="firstname" name="firstname" formControlName="firstname">
      <input type="text" id="lastname" name="lastname" formControlName="lastname">
      <form [formGroup]="contactForm" (ngSubmit)="onSubmit()">





=================================================reactive forms ,vs template driven forms?
Below are the main differences between reactive forms and template driven forms

Feature	                                Reactive	                                                                 Template-Driven

Form model setup	         Created(FormControl instance) in component explicitly	                             Created by directives
Data updates	             Synchronous	                                                                          Asynchronous
Form custom validation	   Defined as Functions	                                                              Defined as Directives
Testing	                   No interaction with change detection cycle	                                  Need knowledge of the change detection process
Mutability	               Immutable(by always returning new value for FormControl instance)	            Mutable(Property always modified to new value)
Scalability	               More scalable using low-level APIs	                                          Less scalable using due to abstraction on APIs



=================================================,dynamic forms?===============================
Dynamic forms is a pattern in which we build a form dynamically based on metadata that describes a business object model. 
You can create them based on reactive form API.

  =========================================What is ,formBuilder

The FormBuilder is the helper API to build forms in Angular.  
It provides shortcuts to create the instance of the FormControl, FormGroup or FormArray. 
It reduces the code required to write the complex forms.

ex:-
 
import { FormBuilder } from '@angular/forms'
 
Next, we need to inject it into our component class
 
constructor(private formBuilder: FormBuilder) {
}




=================================================How do you update specific properties of a form model?(,updateSpecificProperties)

You can use patchValue() method to update specific properties defined in the form model. 
For example,you can update the name and street of certain profile on click of the update button as shown below.

updateProfile() {
  this.userProfile.patchValue({
    firstName: 'John',
    address: {
      street: '98 Crescent Street'
    }
  });
}
  <button (click)="updateProfile()">Update Profile</button>
You can also use setValue method to update properties.

Note: Remember to update the properties against the exact model structure.



==========================================,setValue

setValue(value: { [key: string]: any; }, options: { onlySelf?: boolean; emitEvent?: boolean; } = {}): void

We use the SetValue to update the FormControl , FormGroup or FormArray. 
When we use it to update the FormGroup or FormArray the SetValue requires that the object must match the structure of the FormGroup or FormArray exactly. 
Otherwise, it will result in an error.

==========================================,patchValue
patchValue(value: { [key: string]: any; }, options: { onlySelf?: boolean; emitEvent?: boolean; } = {}): void

The PatchValue is used to update only a subset of the elements of the FormGroup or FormArray. It will only update the matching objects and ignores the rest.



===========================================What is ,formControl

 
ex:-First Name : <input type="text" name="firstname" /> 
 
As a developer, you would like to know the current value in the text box. 
You would also be like to know if the value is valid or not.. If the user has changed the value(dirty) or is it unchanged. 
You would like to be notified when the user changes its value.

The FormControl is an object that encapsulates all the information related to the single input element. It Tracks the value and validation status of each of these control.

The FormControl is just a class. A FormControl is created for each form field. We can refer to them in our component class and inspect its properties and methods

We can use FormControl to set the value of the Form field. Find the status of form field like (valid/invalid, pristine/dirty, touched/untouched ), etc. You can add validation rules to it.
  


===================================================What are the different ways to group form controls?
Reactive forms provide two ways of grouping multiple related controls.

FormGroup:FormGroup: It defines a form with a fixed set of controls those can be managed together in an one object. 
                     It has same properties and methods similar to a FormControl instance. This FormGroup can be nested to create complex forms
FormArray:It defines a dynamic form in an array format, where you can add and remove controls at run time. 
          This is useful for dynamic forms when you don‚Äôt know how many controls will be present within the group.

=============================================,formGroup

The FormGroup is a collection of Form controls It Tracks the value and validity state of a group of Form control instances. 
The FormGroup is one of the building blocks of the angular forms. The other two are FormControl and FormArray.

We create a FormControl for each of these input fields. It tracks the value & validity of these elements. 
All of the above input fields are represented as the separate FormControl. If we wanted to check the validity of our form, 
                                            we have to check the validity of each and every FormControl for validity. 
Imagine a form having a large no of fields. It is cumbersome to loop over large no of FormControls and check for validity

The FormGroup solve‚Äôs this issue by providing a wrapper around a collection of FormControls It encapsulates all the information related to a group of form elements. 
It Tracks the value and validation status of each of these control. 
We can use it to check the validity of the elements. set its values & listen for change events, add and run validations on the group, etc

The FormGroup is just a class. We create a FormGroup to organize and manage the related elements. 
For Example form elements like address, city.state, pin code etc can be grouped together as a single FormGroup. 
It makes it easier to manage them. 
A FormGroup aggregates the values of each child FormControl into one object, with each control name as the key. 
It calculates its status by reducing the status values of its children. 
For example, if one of the controls in a group is invalid, the entire group becomes invalid.



=============================,formControl,status 
The FormGroup tracks the validation status of all the FormControls, which is part of the FormGroup. That also includes the status of nested FormGroup or FormArray. 
If any of the control becomes invalid, then the entire FormGroup becomes invalid.

The following is the list of status-related properties

status
status: string

The Angular runs validation checks, whenever the value of a form control changes. Based on the result of the validation, the FormGroup can have four possible states.

VALID: All the controls of the FormGroup has passed all validation checks.
INVALID: At least one of the control has failed at least one validation check.
PENDING: This Group is in the midst of conducting a validation check.
DISABLED: This FormGroup is exempt from validation checks

//reactive forms
this.reactiveForm.status


==========================================What is ,formArray
The FormArray is a way to manage the collection of Form Controls in Angular. 
The controls can be a FormGroup, FormControl, or another FormArray.

We can group Form Controls in Angular forms in two ways. One is using the FormGroup and the other one is FormArray. 
The difference is how they implement it. In FormGroup controls becomes a property of the FormGroup. Each control is represented as key-value pair. 
While in FormArray, the controls become part of an array



===========================================,validators in Reactive Forms
What is a Validator
A Validator is a function that checks the instance of FormControl, FormGroup or a FormArray and returns a list of errors. 
If the Validator returns a null means that validation has passed


===========================================Built-in Validators  (,builtInValidators)
The Angular ReactiveForms Module provides several Built-in validators out of the box. They are required, minlength, maxlength & pattern etc.























===============================How do you create ,displayBlock components?
By default, Angular CLI creates components in an inline displayed mode(i.e, display:inline). 
But it is possible to create components with display: block style using displayBlock option,

ng generate component my-component --displayBlock
(OR) the option can be turned on by default in Angular.json with schematics.@schematics/angular:component.displayBlock key value as true.


==================================What classes should not be added to declarations?
The below class types shouldn't be added to declarations

A class which is already declared in any another module.
Directives imported from another module.
Module classes.
Service classes.
Non-Angular classes and objects, such as strings, numbers, functions, entity models, configurations, business logic, and helper classes.


=======================================What is ,ngcc?
The ngcc(Angular Compatibility Compiler) is a tool which upgrades node_module compiled with non-ivy ngc into ivy compliant format. 
The postinstall script from package.json will make sure your node_modules will be compatible with the Ivy renderer.

"scripts": {
   "postinstall": "ngcc"
}
Whereas, Ivy compiler (ngtsc), which compiles Ivy-compatible code.


======================================Can I share services using modules?
No, it is not recommended to share services by importing module. 
i.e Import modules when you want to use directives, pipes, and components only. 
The best approach to get a hold of shared services is through 'Angular dependency injection' because importing a module will result in a new service instance.


======================================What is a ,sharedModule?============================

The Shared Module is the module in which you put commonly used directives, pipes, and components into one module that is shared(import it) throughout the application.

For example, the below shared module imports CommonModule, FormsModule for common directives and components, pipes and directives based on the need,

import { CommonModule } from '@angular/common';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { UserComponent } from './user.component';
import { NewUserDirective } from './new-user.directive';
import { OrdersPipe } from './orders.pipe';

@NgModule({
 imports:      [ CommonModule ],
 declarations: [ UserComponent, NewUserDirective, OrdersPipe ],
 exports:      [ UserComponent, NewUserDirective, OrdersPipe,
                 CommonModule, FormsModule ]
})
export class SharedModule { }




===================================What are the steps to use ,declaration elements?
Below are the steps to be followed to use declaration elements.

Create the element(component, directive and pipes) and export it from the file where you wrote it
Import it into the appropriate module.
Declare it in the @NgModule declarations array.



============================What are the possible errors with declarations?
There are two common possible errors with declarations array,

If you use a component without declaring it, Angular returns an error message.
If you try to declare the same class in more than one module then compiler emits an error.


=================================What are the imported modules in CLI generated feature modules?

In the CLI generated feature module, there are two JavaScript import statements at the top of the file

NgModule: InOrder to use the @NgModule decorator
CommonModule: It provides many common directives such as ngIf and ngFor



========================================What are feature modules?(,featureModules)
Feature modules are NgModules, which are used for the purpose of organizing code. The feature module can be created with Angular CLI using the below command 
in the root directory,

ng generate module MyCustomFeature //


==================================Give few examples for NgModules?

The Angular core libraries and third-party libraries are available as NgModules.

Angular libraries such as FormsModule, HttpClientModule, and RouterModule are NgModules.
Many third-party libraries such as Material Design, Ionic, and AngularFire2 are NgModules.



===================================How does angular finds components, directives and pipes?

The Angular compiler finds a component or directive in a template when it can match the selector of that component or directive in that template. 
Whereas it finds a pipe if the pipe's name appears within the pipe syntax of the template HTML.



=====================================What is the role of ,ngModule metadata in compilation process?

The @NgModule metadata is used to tell the Angular compiler what components to be compiled for this module and how to link this module with other modules.


What is Angular compiler?(,compiler)
The Angular compiler is used to convert the application code into JavaScript code. It reads the template markup, combines it with the corresponding component class code,
 and emits component factories which creates JavaScript representation of the component along with elements of @Component metadata.



======================================What is a routed entry component?(,routedEntryComponent)

The components referenced in router configuration are called as routed entry components. This routed entry component defined in a route definition as below,

const routes: Routes = [
  {
    path: '',
    component: TodoListComponent // router entry component
  }
];



===================What is the difference between ngIf ,vs hidden property?
The main difference is that *ngIf will remove the element from the DOM, while [hidden] actually plays with the CSS style by setting display:none. 
Generally it is expensive to add and remove stuff from the DOM for frequent actions.



================================What is the purpose of hidden property?(,hiddenProperty)

The hidden property is used to show or hide the associated DOM element, based on an expression. It can be compared close to ng-show directive in AngularJS. Let's say you want to show user name based on the availability of user using hidden property.

<div [hidden]="!user.name">
  My name is: {{user.name}}
</div>



=========================================What is the purpose of base href tag?(,baseHref)

The routing application should add element to the index.html as the first child in the tag in order to indicate how to compose navigation URLs. 
If app folder is the application root then you can set the href value as below

<base href="/">


=================================What are router links?(,routerLinks)

The RouterLink is a directive on the anchor tags give the router control over those elements. 
Since the navigation paths are fixed, you can assign string values to router-link directive as below,

<h1>Angular Router</h1>
<nav>
  <a routerLink="/todosList" >List of todos</a>
  <a routerLink="/completed" >Completed todos</a>
</nav>
<router-outlet></router-outlet>



====================================What are active router links?(,activeRouterLinks)

RouterLinkActive is a directive that toggles css classes for active RouterLink bindings based on the current RouterState. 
i.e, The Router will add CSS classes when this link is active and remove when the link is inactive. For example, you can add them to RouterLinks as below.

<h1>Angular Router</h1>
<nav>
  <a routerLink="/todosList" routerLinkActive="active">List of todos</a>
  <a routerLink="/completed" routerLinkActive="active">Completed todos</a>
</nav>
<router-outlet></router-outlet>



==============================What is router state?(,routerState)

RouterState is a tree of activated routes. 
Every node in this tree knows about the "consumed" URL segments, the extracted parameters, and the resolved data. 
You can access the current RouterState from anywhere in the application using the Router service and the routerState property.

@Component({templateUrl:'template.html'})
class MyComponent {
  constructor(router: Router) {
    const state: RouterState = router.routerState;
    const root: ActivatedRoute = state.root;
    const child = root.firstChild;
    const id: Observable<string> = child.params.map(p => p.id);
    //...
  }
}
          
          (or)

The RouteState is an interface which represents the state of the router as a tree of activated routes.

interface RouterState extends Tree {
  snapshot: RouterStateSnapshot
  toString(): string
}
You can access the current RouterState from anywhere in the Angular app using the Router service and the routerState property.




=====================================How do you use ,jquery in Angular?

You can use jquery in Angular using 3 simple steps,

Install the dependency: At first, install the jquery dependency using npm
   npm install --save jquery
Add the jquery script: In Angular-CLI project, add the relative path to jquery in the angular.json file.
"scripts": [
   "node_modules/jquery/dist/jquery.min.js"
]



====================================What is ,protractor?

Protractor is an end-to-end test framework for Angular and AngularJS applications. It runs tests against your application running in a real browser, interacting with it as a user would.

npm install -g protractor



==============================What are Http Interceptors?(,httpInterceptor)
Http Interceptors are part of @angular/common/http, which inspect and transform HTTP requests from your application to the server and vice-versa on HTTP responses. These interceptors can perform a variety of implicit tasks, from authentication to logging.

The syntax of HttpInterceptor interface looks like as below,

interface HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>
}



====================================What are the applications of HTTP interceptors?(,httpInterceptor)
The HTTP Interceptors can be used for different variety of tasks,

Authentication
Logging
Caching
Fake backend
URL transformation
Modifying headers



===================================================What is the purpose of innerHTML?(,innerHTML)
The innerHtml is a property of HTML-Elements, which allows you to set it's html-content programmatically. Let's display the below html code snippet in a <div> tag as below using innerHTML binding,

<div [innerHTML]="htmlSnippet"></div>
and define the htmlSnippet property from any component

export class myComponent {
  htmlSnippet: string = '<b>Hello World</b>, Angular';
}
Unfortunately this property could cause Cross Site Scripting (XSS) security bugs when improperly handled.



=======================================What is ,schematic?
It's a scaffolding library that defines how to generate or transform a programming project by creating, modifying, refactoring, or moving files and code. 
It defines rules that operate on a virtual file system called a tree.




======================================What is rule in Schematics?(schematicRulle)
In schematics world, it's a function that operates on a file tree to create, delete, or modify files in a specific manner.



=========================================What is Schematics CLI?(.schematicsCli)
Schematics come with their own command-line tool known as Schematics CLI. 
It is used to install the schematics executable, which you can use to create a new schematics collection with an initial named schematic. The collection folder is a workspace for schematics. You can also use the schematics command to add a new schematic to an existing collection, or extend an existing schematic. You can install Schematic CLI globally as below,

npm install -g @angular-devkit/schematics-cli




==========================How to use ,polyfills in Angular application?

The Angular CLI provides support for polyfills officially. When you create a new project with the ng new command, a src/polyfills.ts configuration file is created as part of your project folder. 
This file includes the mandatory and many of the optional polyfills as JavaScript import statements. Let's categorize the polyfills,

Mandatory polyfills: 
       These are installed automatically when you create your project with ng new command and the respective import statements enabled in 'src/polyfills.ts' file.
Optional polyfills: 
       You need to install its npm package and then create import statement in 'src/polyfills.ts' file. 
       For example, first you need to install below npm package for adding web animations (optional) polyfill. bash npm install --save web-animations-js and 
           create import statement in polyfill file. javascript import 'web-animations-js';




=====================================How do you ,upgrade angular version?
The Angular upgrade is quite easier using Angular CLI ng update command as mentioned below. 
For example, if you upgrade from Angular 7 to 8 then your lazy loaded route imports will be migrated to the new import syntax automatically.

$ ng update @angular/cli @angular/core




=====================================What is lazy loading?(,lazyLoading)
Lazy loading is one of the most useful concepts of Angular Routing. 
It helps us to download the web pages in chunks instead of downloading everything in a big bundle. 
It is used for lazy loading by asynchronously loading the feature module for routing whenever required using the property loadChildren. 
Let's load both Customer and Order feature modules lazily as below,

const routes: Routes = [
  {
    path: 'customers',
    loadChildren: () => import('./customers/customers.module').then(module => module.CustomersModule)
  },
  {
    path: 'orders',
    loadChildren: () => import('./orders/orders.module').then(module => module.OrdersModule)
  },
  {
    path: '',
    redirectTo: '',
    pathMatch: 'full'
  }
];




==================================================How do you select an element with in a component template?(componentTemplate)
You can use @ViewChild directive to access elements in the view directly. Let's take input element with a reference,

<input #uname>
and define view child directive and access it in ngAfterViewInit lifecycle hook

@ViewChild('uname') input;

ngAfterViewInit() {
  console.log(this.input.nativeElement.value);
}



=========================================================What is ,platform in Angular?
A platform is the context in which an Angular application runs. The most common platform for Angular applications is a web browser, but it can also be an operating system for a mobile device, or a web server. The runtime-platform is provided by the @angular/platform-* packages and these packages allow applications that make use of @angular/core and @angular/common to execute in different environments. i.e, Angular can be used as platform-independent framework in different environments, For example,

While running in the browser, it uses platform-browser package.
When SSR(server-side rendering ) is used, it uses platform-server package for providing web server implementation




==========================What is a DI token?(,diToken)
A DI token is a lookup token associated with a dependency provider in dependency injection system. 
The injector maintains an internal token-provider map that it references when asked for a dependency and the DI token is the key to the map. 

Let's take example of DI Token usage,

const BASE_URL = new InjectionToken<string>('BaseUrl');
const injector =
   Injector.create({providers: [{provide: BASE_URL, useValue: 'http://some-domain.com'}]});
const url = injector.get(BASE_URL);



=============================What are the case types in Angular?(,caseTypes)
Angular uses capitalization conventions to distinguish the names of various types. Angular follows the list of the below case types.

camelCase : Symbols, properties, methods, pipe names, non-component directive selectors, constants uses lowercase on the first letter of the item. For example, "selectedUser"
UpperCamelCase (or PascalCase): Class names, including classes that define components, interfaces, NgModules, directives, and pipes uses uppercase on the first letter of the item.
dash-case (or "kebab-case"): The descriptive part of file names, component selectors uses dashes between the words. For example, "app-user-list".
UPPER_UNDERSCORE_CASE: All constants uses capital letters connected with underscores. For example, "NUMBER_OF_USERS".



==========================================What is a builder?
A builder function is a function that uses the Architect API to perform a complex process such as "build" or "test". 
The builder code is defined in an npm package. 
For example:-
 BrowserBuilder runs a webpack build for a browser target and KarmaBuilder starts the Karma server and runs a webpack build for unit tests.



=====================================How do you invoke a builder?
The Angular CLI command ng run is used to invoke a builder with a specific target configuration. 
The workspace configuration file, angular.json, contains default configurations for built-in builders.



======================================What is Angular CLI Builder?(,cliBuilder)(,builder)

In Angular8, the CLI Builder API is stable and available to developers who want to customize the Angular CLI by adding or modifying commands. 
For example, you could supply a builder to perform an entirely new task, or to change which third-party tool is used by an existing command.


===================================What is Angular Language Service?

The Angular Language Service is a way to get completions, errors, hints, and navigation inside your Angular templates whether they are external in an HTML file 
     or embedded in annotations/decorators in a string. 
It has the ability to autodetect that you are opening an Angular file, reads your tsconfig.json file, finds all the templates you have in your application, and then 
    provides all the language services.


=============================How do you install angular language service in the project?(,installLanguageService)(,languageService)
You can install Angular Language Service in your project with the following npm command,

npm install --save-dev @angular/language-service
After that add the following to the "compilerOptions" section of your project's tsconfig.json

"plugins": [
    {"name": "@angular/language-service"}
]
Note: The completion and diagnostic services works for .ts files only. You need to use custom plugins for supporting HTML files



===============================Is there any editor support for Angular Language Service?(,editorSupport)(,languageService)
Yes, Angular Language Service is currently available for Visual Studio Code and WebStorm IDEs. 
You need to install angular language service using an extension and devDependency respectively. 
In sublime editor, you need to install typescript which has has a language service plugin model.



==============================What is Angular Ivy?(,ivy)
Angular Ivy is a new rendering engine for Angular. You can choose to opt in a preview version of Ivy from Angular version 8.

You can enable ivy in a new project by using the --enable-ivy flag with the ng new command

ng new ivy-demo-app --enable-ivy
You can add it to an existing project by adding enableIvy option in the angularCompilerOptions in your project's tsconfig.app.json.

{
  "compilerOptions": { ... },
  "angularCompilerOptions": {
    "enableIvy": true
  }
}


==========================Can I use AOT compilation with Ivy?

Yes, it is a recommended configuration. Also, AOT compilation with Ivy is faster. So you need set the default build options(with in angular.json) for your project to always use AOT compilation.

{
  "projects": {
    "my-project": {
      "architect": {
        "build": {
          "options": {
            ...
            "aot": true,
          }
        }
      }
    }
  }
}



============================What are the differences between AngularJS and Angular with respect to dependency injection?

Dependency injection is a common component in both AngularJS and Angular, but there are some key differences between the two frameworks in how it actually works.

                      AngularJS	                                                                         Angular
Dependency injection tokens are always strings	Tokens can have different types.          They are often classes and sometimes can be strings.
There is exactly one injector even though it is a multi-module applications	              There is a tree hierarchy of injectors, with a root injector and an 
                                                                                             additional injector for each component.



======================What are the features included in ivy preview?(,ivyFeatures)

You can expect below features with Ivy preview,

Generated code that is easier to read and debug at runtime
Faster re-build time
Improved payload size
Improved template type checking



=============================================What is transition function?(,transitionFunction)
The animation transition function is used to specify the changes that occur between one state and another over a period of time. It accepts two arguments: the first argument accepts an expression that defines the direction between two transition states, and the second argument accepts an animate() function.

Let's take an example state transition from open to closed with an half second transition between states.

transition('open => closed', [
  animate('500ms')
]),


===============================What is the purpose of animate function?(,animateFunction)

Angular Animations are a powerful way to implement sophisticated and compelling animations for your Angular single page web application.



===============================What is the purpose of common module?(,commonModule)

The commonly-needed services, pipes, and directives provided by @angular/common module. Apart from these HttpClientModule is available under @angular/common/http.


===============================How do you describe various dependencies in angular application?(,dependencies)

The dependencies section of package.json with in an angular application can be divided as follow,

Angular packages: Angular core and optional modules; their package names begin @angular/.
Support packages: Third-party libraries that must be present for Angular apps to run.
Polyfill packages: Polyfills plug gaps in a browser's JavaScript implementation



=================================What is the purpose of metadata json files?(,metadataJson)
The metadata.json file can be treated as a diagram of the overall structure of a decorator's metadata, represented as an abstract syntax tree(AST). 
During the analysis phase, the AOT collector scan the metadata recorded in the Angular




===============================Can I use arrow functions in AOT?

No, Arrow functions or lambda functions can‚Äôt be used to assign values to the decorator properties. For example, the following snippet is invalid:

@Component({
  providers: [{
    provide: MyService, useFactory: () => getService()
  }]
})
To fix this, it has to be changed as following exported function:

function getService(){
  return new MyService();
}

@Component({
  providers: [{
    provide: MyService, useFactory: getService
  }]
})

If you still use arrow function, it generates an error node in place of the function. 
When the compiler later interprets this node, it reports an error to turn the arrow function into an exported function. 
Note: From Angular5 onwards, the compiler automatically performs this rewriting while emitting the .js file.


What are the three phases of AOT?(,threePhasesOfAot)(,aot)

The AOT compiler works in three phases,
Code Analysis: The compiler records a representation of the source
Code generation: It handles the interpretation as well as places restrictions on what it interprets.
Validation: In this phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.


===========================================.advantages with AOT?

Below are the list of AOT benefits,

Faster rendering:              The browser downloads a pre-compiled version of the application. So it can render the application immediately without compiling the app.
Fewer asynchronous requests:   It inlines external HTML templates and CSS style sheets within the application javascript which eliminates separate ajax requests.
Smaller Angular framework download size:          Doesn't require downloading the Angular compiler. Hence it dramatically reduces the application payload.
Detect template errors earlier:        Detects and reports template binding errors during the build step itself
Better security:               It compiles HTML templates and components into JavaScript. So there won't be any injection attacks


================Do I need a Routing Module always?(,routingModule)(,needOfRoutingModule)

No, the Routing Module is a design choice. 
You can skip routing Module (for example, AppRoutingModule) ,
            when the configuration is simple and merge the routing configuration directly into the companion module (for example, AppModule). 
But it is recommended when the configuration is complex and includes specialized guard and resolver services



============================How do you define routes?(,routesDefine)(,defineRoutes)

A router must be configured with a list of route definitions. 
You configures the router with routes via the RouterModule.forRoot() method, and adds the result to the AppModule's imports array.

 const appRoutes: Routes = [
  { path: 'todo/:id',      component: TodoDetailComponent },
  {
    path: 'todos',
    component: TodosListComponent,
    data: { title: 'Todos List' }
  },
  { path: '',
    redirectTo: '/todos',
    pathMatch: 'full'
  },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes,
      { enableTracing: true } // <-- debugging purposes only
    )
    // other imports here
  ],
  ...
})
export class AppModule { }



================================What are router events?(,routerEvents)

During each navigation, the Router emits navigation events through the Router.events property allowing you to track the lifecycle of the route.

The sequence of router events is as below,

NavigationStart,
RouteConfigLoadStart,
RouteConfigLoadEnd,
RoutesRecognized,
GuardsCheckStart,
ChildActivationStart,
ActivationStart,
GuardsCheckEnd,
ResolveStart,
ResolveEnd,
ActivationEnd
ChildActivationEnd
NavigationEnd,
NavigationCancel,
NavigationError
Scroll



Router events in Angular refer to events that are emitted by the Angular Router during various stages of navigation. These events allow you to hook into the navigation lifecycle and perform actions or handle scenarios based on the state of the navigation. Some of the commonly used router events include:

NavigationStart: This event is emitted when navigation starts.

RouteConfigLoadStart: This event is emitted before a lazy-loaded route configuration is loaded.

RouteConfigLoadEnd: This event is emitted after a lazy-loaded route configuration has been loaded.

RoutesRecognized: This event is emitted when the router has successfully recognized a URL and identified the corresponding route.

GuardsCheckStart: This event is emitted before the guards are checked during navigation.

GuardsCheckEnd: This event is emitted after the guards have been checked during navigation.

ResolveStart: This event is emitted before the route data is resolved during navigation.

ResolveEnd: This event is emitted after the route data has been resolved during navigation.

NavigationEnd: This event is emitted when navigation ends successfully.

NavigationCancel: This event is emitted when navigation is canceled, usually due to a navigation guard returning false.

NavigationError: This event is emitted when navigation encounters an error.

These events provide hooks that allow you to perform tasks at different stages of the navigation process. For example, you might want to show a loading spinner during navigation, fetch additional data before displaying a component, or prevent navigation under certain conditions.

To use router events, you can subscribe to them in your component or service. Here's an example of how you might use the NavigationStart event:

typescript
Copy code
import { Component, OnInit } from '@angular/core';
import { Router, NavigationStart } from '@angular/router';

@Component({
  selector: 'app-my-component',
  template: '...',
})
export class MyComponent implements OnInit {
  constructor(private router: Router) {}

  ngOnInit() {
    this.router.events.subscribe((event) => {
      if (event instanceof NavigationStart) {
        // Do something when navigation starts
        console.log('Navigation is starting...');
      }
    });
  }
}




















====================================================================,html=====================================================

======================,hyprtText====

text means normal text ,hypertest means inclusion of images,text,links all are mixed so called hypertext



=====================,versions of html
HTML 1.0
HTML 2.0
HTML 3.0
HTML 3.2
HTML 4.01

XHTML 1.0

HTML5



=========================HTML ,vs XHTML===========

                 HTML                                                                                              XHTML

start tags are not required for every element                                                 All elements must have a start tags

end tags are ................................                                                 Non-void elements with a start tag must have an end tag(p and li ,example)

Only void elements such as br,img, and link may be "self-closed" with />                      Any element may be self closed using />

Tags and attributes are case-insensitive                                                      sensitive ,typically lowercase

Attributes donot need to be quoted                                                            must be enclosed in quotes

Some attributes may be empty(such as checked and disabled)                                    Empty attributes are forbidden(ex:checked="checked" or checked ="true")

special characters,or entities,do not have to be escaped                                      special characters must be escaped using character entities.




======================================== What are the building blocks of HTML5?(,buildingBlocks of html5)

Semantics: allowing you to describe more precisely what your content is.
Connectivity: allowing you to communicate with the server in new and innovative ways.
Offline and storage: allowing webpages to store data on the client-side locally and operate offline more efficiently.
Multimedia: making video and audio first-class citizens in the Open Web.
2D/3D graphics and effects: allowing a much more diverse range of presentation options.
Performance and integration: providing greater speed optimization and better usage of computer hardware.
Device access: allowing for the usage of various input and output devices.
Styling: letting authors write more sophisticated themes.


==============================semantic and non-semantic elements?(,semantic ,vs ,non-semantic)(semantic ,vs non-semantic)

Semantic elements: clearly describes its meaning to both the browser and the developer. 
For example: 
<form>, <table>, <article>, <aside>, <details>, <figcaption>, <figure>, <footer>, <header>, <main>, <mark>, <nav>, <section>, <summary>, <time> clearly defines its content.

Non-semantic elements: <div> and <span> tells nothing about its content.



========================================= What are the semantic tags available in html5?(,sematicTags)

Semantic HTML refers to syntax that makes the HTML more comprehensible by better defining the different sections and layout of web pages. 
It makes web pages more informative and adaptable, allowing browsers and search engines to better interpret content


Semantic HTML elements are those that clearly describe their meaning in a human- and machine-readable way. 
Elements such as 
   <header> , 
   <footer> and 
   <article> 
   are all considered semantic because they accurately describe the purpose of the element and the type of content that is inside them.

//HTML5 semantic tags define the function and the category of your text, simplifying the work for browsers and search engines, as well as developers.

HTML5 offers new semantic elements to define different parts of a web page:

<article>
<aside>
<details>
<figcaption>
<figure>
<footer>
<header>
<main>
<mark>
<nav>
<section>
<summary>
<time>
Syntax:

<!DOCTYPE html> 

<html>  
   <head> 
      <meta charset = "utf-8"/> 
      <title>...</title> 
   </head> 
  
   <body> 
      <header>...</header> 
      <nav>...</nav> 
      
      <article> 
         <section> 
            ... 
         </section> 
      </article> 
      <aside>...</aside> 
      
      <footer>...</footer> 
   </body> 
</html> 





============================,docType

All HTML documents must start with a <!DOCTYPE> declaration.
 
The <!DOCTYPE> declaration is not an HTML tag; 
it is an instruction to the web browser about what version of HTML the page is written in.
<!DOCTYPE html> // Tells the browser that we are using HTML5.

If document type is not mentioned, browser will go to Quirks mode. 
Quirks mode depends upon the web browser version, If is older version then this will not support HTML5 tags (Example: header tag, footer tag, section tag,...)



===================================What are the new form elements in HTML5?(,newFormElements)

There are five new form elements in the HTML5 forms specification: <datalist>, <output>, <progress>, and <meter>.

1. Datalist Tag

Allows to attach a list of suggestions to a text input element. 
As soon as the user begins to type in the text field, the list of suggestions appears and the user can choose from the suggestions with the mouse.

<p>Enter your favorite browser name:</p>
<input type="text" list="browsers" name="favorite_browser">
<datalist id="browsers">
    <option value="Firefox">
    <option value="Chrome">    
    <option value="Internet Explorer">
    <option value="Opera">
    <option value="Safari">
</datalist>

2. Meter Tag

Indicates a numeric value that falls within a range. 
The tag supports a number of attributes: value: If you don't specify a value, the first numeric value inside the <meter></meter> pair becomes the value.

max: The maximum possible value of the item.
min: The minimum possible value of the item.
high: If the value can be defined as a range, this is the high end of the range.
low: If the value can defined as a range, this is the low end of that range.
optimum: The optimal value of the element.
<p>Disk Usage: <meter value="0.2">20%</meter></p>

<p>Total Score: <meter value="6" min="0" max="10">6 out of 10</meter></p>

<p>Pollution Level: <meter low="60" high="80" max="100" value="85">Very High</meter></p>

3. Output Tag

It indicates a section of the page that can be modified by a script (usually JavaScript).

<form oninput="result.value=parseInt(a.value)+parseInt(b.value)">
  <input type="range" id="a" value="50"> +
  <input type="number" id="b" value="100"> =
  <output name="result" for="a b"></output>
</form>

4. Progress Tag

Indicates how much of a task has been completed (often marked as a percentage). It is expected to be modified through JavaScript code.

 
<p>Progress: <progress id="bar" value="0" max="100"><span>0</span>%</progress></p>

<script type="text/javascript">
    var i = 0;
    var progressBar = document.getElementById("bar");
    
    function countNumbers() {
      if(i < 100) {
        i = i + 1;
        progressBar.value = i;
        // For browsers that don't support progress tag
        progressBar.getElementsByTagName("span")[0].textContent = i;
      }

      // Wait for sometime before running this script again
      setTimeout("countNumbers()", 100);
    }
    countNumbers();
</script>



=======================================How many new form elements are introduced in html5?(,newFormElements)

Sl.No	Element	Description
01.	color	Gives the end user a native color picker to choose a color.
02.	date	Offers a datepicker.
03.	datetime	An element to choose both date and time.
04.	datetime-local	An element to choose both date and time, with local settings support.
05.	email	A field for entering e-mail address(es).
06.	month	Choose a full month.
07.	number	Picking a number.
08.	range	Offers a slider to set to a certain value/position.
09.	search	A field for search queries.
10.	tel	Choosing a telephone number.
11.	time	Input a certain time.
12.	url	Entering a URL.
13.	week	Picking a specific week.
Example:

<input type="color" value="#b97a57">

<input type="date" value="2020-06-08">

<input type="datetime" value="2020-06-09T20:35:34.32">

<input type="datetime-local" value="2020-06-09T22:41">

<input type="email" value="robert@robertnyman.com">

<input type="month" value="2020-06">

<input type="number" value="4">

<input type="range" value="15">

<!-- Note: If not set, default attribute values are min="0", max="100", step="1". -->

<input type="search" value="[Any search text]">

<input type="tel" value="[Any numeric value]">

<!-- Note: Most web browsers seem to let through any value at this time. -->

<input type="time" value="22:38">

<input type="url" value="https://www.google.com/">

<!-- Note: requires a protocol like http://, ftp:// etc in the beginning. -->


<input type="week" value="2020-W24">





==================================What is difference between span tag and div tag?(span ,vs div)

The primary difference between div and span tag is their default behavior. By default, a <div> is a block-level-element and a <span> is an inline element.

<div> is a block level element which means it will render it on it's own line with a width of a 100% of the parent element.

<span> is an inline element which means it will render on the same line as the previous element, if it is also an inline element, and 
it's width will be determined by it's content.
<div>Demo Text, with <span>some other</span> text.</div>




=================================,optionalClosingTag?

<p>, <li>, <td>, <tr>, <th>, <html>, <body>, etc. don't have to provide end tag. 
Whenever browser hits a new tag it automatically ends the previous tag.



=============================,self closing tag?(,selfClosingTag)

In HTML5 it is not strictly necessary to close certain HTML tags. The tags that aren't required to have specific closing tags are called ‚Äúself closing‚Äù tags.

An example of a self closing tag is something like a line break (<br />) or the meta tag (<meta>). This means that the following are both acceptable:

<meta charset="UTF-8">
...
<meta charset="UTF-8" />



============================================= What is the purpose of main element?(,mainElement)

The HTML <main> element represents the dominant content of the <body> of a document. 
The main content area consists of content that is directly related to or expands upon the central topic of a document, or the central functionality of an application.

<main role="main">
    <p>Geckos are a group of usually small, usually nocturnal lizards. 
       They are found on every continent except Australia.</p>
    <p>Many species of gecko have adhesive toe pads which enable them to climb walls and even windows.</p>
</main>
Note: A document mustn't have more than one <main> element that doesn't have the hidden attribute specified.



==========================================What are the ,semantic meanings and how should each be used in structuring html markup?

<header> is used to contain introductory and navigational information about a section of the page. 
           This can include the section heading, the author's name, time and date of publication, table of contents, or other navigational information.

<article> is meant to house a self-contained composition that can logically be independently recreated outside of the page without losing it's meaining. 
           Individual blog posts or news stories are good examples.

<section> is a flexible container for holding content that shares a common informational theme or purpose.

<footer> is used to hold information that should appear at the end of a section of content and contain additional information about the section. 
           Author's name, copyright information, and related links are typical examples of such content.


===================================Can a web page contain multiple <header> elements? What about <footer> elements?(,multipleHeader,footer)

Yes, header elements can be used multiple times in documents. 
A <header> tag must be present for all articles, sections, and pages, although a <footer> tag is not necessary.



=====================,section, ,div or ,article?
<section>, group of content inside is related to a single theme, and should appear as an entry in an outline of the page. 
             It's a chunk of related content, like a subsection of a long article, a major part of the page (eg the news section on the homepage), or 
                              a page in a webapp's tabbed interface. 
             A section normally has a heading (title) and maybe a footer too.

<article>, represents a complete, or self-contained, composition in a document, page, application, or site and that is, in principle, independently distributable or 
            reusable, 
         e.g. in syndication. This could be a forum post, a magazine or newspaper article, a blog entry, a user-submitted comment, an interactive widget or gadget, or 
            any other independent item of content.

<div>, on the other hand, does not convey any meaning, aside from any found in its class, lang and title attributes.




===============================,physicalTags and ,logicalTags in HTML?

1. Physical Tags:

Physical tags are used to indicate how a particular character is to be formatted. 
Any physical style tag may contain any item allowed in text, including conventional text, images, line breaks, etc.

Example:

Tags	Description
<sup>	Superscript is usually used for showing elements above base-line
<sub>	The subscript is used for alternate baseline.
<i>	An Italic tag is used to define a text with a special meaning.
<big>	Big tag increase the font size by 1 (Note: You can not use the big tag in HTML 5)
<small>	A small tag defines the small text, and it is used while writing copyright.
<b>	Bold increases the importance of the text because bold tag covert the text into bold size.
<u>	It is used to underline the text.
<tt>	Teletype text gives the default font-family which is monospace.
<strike>	It is an editing markup that tells the reader to ignore the text passage.


2. Logical Tags:

Logical tags are used to tell the browser what kind of text is written inside the tags. 
Logical tags are also known as Structural tags because they specify the structure of the document. 
Logical tags are used to indicate to the visually impaired person that there is something more important in the text or to emphasize the text ie, logical tags can be used for styling purposes as well as to give special importance to text content.

Example:

Tags	Description
<abbr>	Defines the abbreviation of text.
<acronym>	Defines the acronym.
<address>	Contact information of a person or an organization.
<cite>	Defines citation. It displays the text in italic format.
<code>	Defines the piece of computer code.
<blockquote>	Defines a long quotation.
<del>	Defines the deleted text and is used to mark a portion of text which has been deleted from the document.
<dfn>	Defines the definition element and is used to representing a defining instance in HTML.
<ins>	Defines inserted text.
<kbd>	Defines keyboard input text.
<pre>	Defines the block of preformatted text which preserves the text spaces, line breaks, tabs, and other formatting characters which are ignored by web browsers.
<q>	Defines the short quotation.
<samp>	Defines the sample output text from a computer program.
<strong>	Defines strong text i.e. show the importance of the text.
<var>	Defines the variable in a mathematical equation or in the computer program.


========================What is the purpose of meta tags?(,metaTags)

The META elements can be used to include name/value pairs describing properties of the HTML document, such as author, expiry date, a list of keywords, document author etc.

<!DOCTYPE html>
<html>
  <head>
        <!--Recommended Meta Tags-->
        <meta charset="utf-8">
        <meta name="language" content="english"> 
        <meta http-equiv="content-type" content="text/html">
        <meta name="author" content="Author Name">
        <meta name="designer" content="Designer Name">
        <meta name="publisher" content="Publisher Name">
        <meta name="no-email-collection" content="name@email.com">
        <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

        <!--Search Engine Optimization Meta Tags-->
        <meta name="description" content="Project Description">
        <meta name="keywords" content="Software Engineer,Product Manager,Project Manager,Data Scientist">
        <meta name="robots" content="index,follow">
        <meta name="revisit-after" content="7 days">
        <meta name="distribution" content="web">
        <meta name="robots" content="noodp">
        
        <!--Optional Meta Tags-->
        <meta name="distribution" content="web">
        <meta name="web_author" content="">
        <meta name="rating" content="">
        <meta name="subject" content="Personal">
        <meta name="title" content=" - Official Website.">
        <meta name="copyright" content="Copyright 2020">
        <meta name="reply-to" content="">
        <meta name="abstract" content="">
        <meta name="city" content="Bangalore">
        <meta name="country" content="INDIA">
        <meta name="distribution" content="">
        <meta name="classification" content="">
    
        <!--Meta Tags for HTML pages on Mobile-->
        <meta name="format-detection" content="telephone=yes"/>
        <meta name="HandheldFriendly" content="true"/> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/> 
        <meta name="apple-mobile-web-app-capable" content="yes" />
        
        <!--http-equiv Tags-->
        <meta http-equiv="Content-Style-Type" content="text/css">
        <meta http-equiv="Content-Script-Type" content="text/javascript">
      
    <title>HTML5 Meta Tags</title>
  </head>
  <body>
       ...
  </body>
</html>



======================================local storage in html5?(,localStorage)

The localStorage read-only property of the window interface allows you to access a Storage object for the Document's origin; the stored data is saved across browser 
 sessions.

Example:

// Store
localStorage.setItem("name", "Kanti Ahluwalia");

// Retrieve
localStorage.getItem("name"); // Kanti Ahluwalia



=================================== session storage in html5?(,sessionStorage)

The sessionStorage object is equal to the localStorage object, except that it stores the data for only one session. 
The data is deleted when the user closes the specific browser tab.

Example:

// Save data to sessionStorage
sessionStorage.setItem('key', 'value');

// Get saved data from sessionStorage
let data = sessionStorage.getItem('key');

// Remove saved data from sessionStorage
sessionStorage.removeItem('key');

// Remove all saved data from sessionStorage
sessionStorage.clear();



=========================================cookies in html5?(,cookies)

A cookie is an amount of information that persists between a server-side and a client-side. A web browser stores this information at the time of browsing.

A cookie contains the information as a string generally in the form of a name-value pair separated by semi-colons. 
It maintains the state of a user and remembers the user's information among all the web pages.

Example 01: Create a Cookies

// create a cookie
document.cookie = "username=Anjali Batta";

Example 02: Cookie with expiry date

// cookie with expiry date
document.cookie = "username=Anjali Batta; expires=Thu, 18 Dec 2022 12:00:00 UTC";
Example 03: Read Cookie

let myCookies = document.cookie;

console.log(myCookies);
Example 04: Update Cookie

document.cookie = "username=John Smith; expires=Thu, 18 Dec 2022 12:00:00 UTC; path=/";
Example 05: Delete Cookie

document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";



========================cookie, sessionStorage and localStorage?

                               cookie	                                          localStorage	                                    sessionStorage

Initiator	                Client or server. Server can use Set-Cookie header	    Client	                                            Client

Expiry	                  Manually set	                                         Forever	                                         On tab close

Persistent across 
browser sessions	         Depends on whether expiration is set	                    Yes	                                                 No

Capacity (per domain)	                    4kb	                                      5MB	                                                5MB

Accessibility	                           Any window	                             Any window	                                          Same tab

Note: If the user decides to clear browsing data via whatever mechanism provided by the browser, this will clear out any cookie, localStorage, or sessionStorage stored. 
It's important to keep this in mind when designing for local persistance, especially when comparing to alternatives such as server side storing in a database or 
   similar (which of course will persist despite user actions).




==================What is the purpose of the alt attribute on images?(,alt)

The alt attribute provides alternative information for an image if a user cannot view it. 
The alt attribute should be used to describe any images except those which only serve a decorative purposes, in which case it should be left empty.

<img src="pancakes.png" alt="Stack of blueberry pancakes with powdered sugar">



=========================What does enctype='multipart/form-data' mean?(,enctype)

The enctype attribute specifies how the form-data should be encoded when submitting it to the server.

Example: 01

<form action="fileupload.php" method="post" enctype="multipart/form-data"> 
    <p>Please select the file you would like to upload.</p> 
    <input type="file" name="upload"> 
    <br> 
    <input type="submit" value="Upload File">
</form>
Example: 02

<form action="/urlencoded?token=A87412B" method="POST" enctype="application/x-www-form-urlencoded">
    <input type="text" name="username" value=""/>
    <input type="text" name="password" value=""/>
    <input type="submit" value="Submit" />
</form>
Example: 03

<form action="action.do" method="get" enctype="text/plain">
    Name: <input type="text" name="name" />
    Phone: <input type="number" name="phone" />
    <input type="submit" value="Submit" />
</form>

Sl.No 	        Value	                                                                     Description

01.	    application/x-www-form-urlencoded	                               Default.All characters are encoded before sent 
                                                            (spaces are converted to "+" symbols, and special characters are converted to ASCII HEX values)

02.	    multipart/form-data	                                  No characters are encoded. This value is required when you are using forms that have a file upload control

03.	     text/plain	                                               Spaces are converted to "+" symbols, but no special characters are encoded



================================difference between Select and Datalist?(,select ,vs ,datalist)   (select ,vs datalist) 

For the select element, the user is required to select one of the options you've given. 
For the datalist element, it is suggested that the user select one of the options you've given, but he can actually enter anything he wants in the input.

1. Select:

<select name="browser">
  <option value="firefox">Firefox</option>
  <option value="ie">IE</option>
  <option value="chrome">Chrome</option>
  <option value="opera">Opera</option>
  <option value="safari">Safari</option>
</select>
2. Datalist:

<input type="text" list="browsers">
<datalist id="browsers">
  <option value="Firefox">
  <option value="IE">
  <option value="Chrome">
  <option value="Opera">
  <option value="Safari">
</datalist>





======================,dom
     
      dom in html


      üß± What is the DOM?
DOM stands for Document Object Model.

It is a tree-like structure that the browser creates from your HTML code, representing every element on the page as a JavaScript object.

üîç Think of it like this:
Your HTML:

html
Copy
Edit
<html>
  <body>
    <p>Hello</p>
  </body>
</html>
The browser turns it into a DOM Tree like:

css
Copy
Edit
Document
‚îî‚îÄ‚îÄ html
    ‚îî‚îÄ‚îÄ body
        ‚îî‚îÄ‚îÄ p
            ‚îî‚îÄ‚îÄ "Hello"
Each part (html, body, p, text) becomes a DOM node that can be accessed and modified using JavaScript.


‚öôÔ∏è DOM vs HTML
HTML	DOM
What you write in .html file	What the browser creates from HTML
Static text	Live, programmable structure
Can't change after page load	Can be changed via JavaScript


The HTML DOM is an Object Model for HTML. 

When a web page is loaded, the browser creates a Document Object Model of the page.

The HTML DOM model is constructed as a tree of Objects:

It defines:

HTML elements as objects
Properties for all HTML elements
Methods for all HTML elements
Events for all HTML elements




      dom in js
The HTML DOM is an API (Programming Interface) for JavaScript:

JavaScript can add/change/remove HTML elements
JavaScript can add/change/remove HTML attributes
JavaScript can add/change/remove CSS styles
JavaScript can react to HTML events
JavaScript can add/change/remove HTML events


===============Why do we need DOM?(,needOfDom)(,domNeed)(,domUse)

The DOM (Document Object Model) is an interface that represents how your HTML and XML documents are read by the browser. 
It allows a language (JavaScript) to manipulate, structure, and style your website.


=============================,browser rendering ,engine work?

In order to render content the browser has to go through a series of steps:

Document Object Model(DOM)
CSS object model(CSSOM)
Render Tree
Layout
Paint



=====================================standards mode and quirks mode?(standardMode ,vs quirksMode)

In Quirks mode, layout emulates nonstandard behavior in Navigator 4 and Internet Explorer 5. 
This is essential in order to support websites that were built before the widespread adoption of web standards. 


In Standards mode, the behavior is described by the HTML and CSS specifications.

For HTML documents, browsers use a <!DOCTYPE html> in the beginning of the document to decide whether to handle it in quirks mode or standards mode.

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset=UTF-8>
    <title>Hello World!</title>
  </head>
  <body>
  </body>
</html>



==========================================Ways to improve website performance(,websitePerformance)

           ------------Minimize HTTP Requests:

Sites are mainly slow because of too many (or too large) HTTP requests. We can eliminate unnecessary request;
combined files: js to a file, css to a file
CSS sprites: CSS Sprites are the preferred method for reducing the number of image requests. Combine your background images into a single image and use the CSS background-image and background-position properties to display the desired image segment.


          ----------------Use a Content Delivery Network CDN

A CDN is essentially many optimized servers around the world that deliver web content to users based on their geographic location. This means big performance improvements for site users. Because, say, if a person accessing your site in India, they will be retrieving web content from a server nearby
          
          
          ------------------Optimize Images:

image sizes make a huge difference to site speed. The larger content/images, the slower the site. we could:
Changing the resolution: reducing the ‚Äúquality‚Äù of the image (and thereby the file size)
Compressing the picture: increasing the efficiency of image data storage
Cropping the picture: when cropping, you are cutting out unneeded areas and thus making the image smaller in size
        
        
        
        ------------------Put Scripts at the Bottom:

Javascript files can load after the rest of your page. The simplest solution is to place your external Javascript files at the bottom of your page, just before the close of your body tag. Now more of your site can load before your scripts. Another method that allows even more control is to use the defer or async attributes when placing external .js files on your site.

Async tags load the scripts while the rest of the page loads, but this means scripts can be loaded out of order. Basically, lighter files load first. This might be fine for some scripts, but can be disastrous for others.

The defer attribute loads your scripts after your content has finished loading. It also runs the scripts in order. Just make sure your scripts run so late without breaking your site.

       
       
       
        ------------------Add an Expires or a Cache-Control Header

Web page designs are getting richer and richer, which means more scripts, stylesheets, images, and Flash in the page. A first-time visitor to your page may have to make several HTTP requests, but by using the Expires header you make those components cacheable. This avoids unnecessary HTTP requests on subsequent page views. Expires headers are most often used with images, but they should be used on all components including scripts, stylesheets, and Flash components.


              
              
              ----------------------Gzip Components

Compression reduces response times by reducing the size of the HTTP response. Gzipping generally reduces the response size by about 70%.



               -----------------Put Stylesheets at the Top:

This is because putting stylesheets in the HEAD allows the page to render progressively.




                   -------------------Avoid CSS Expressions

                   --------------Use GET for AJAX Requests:

Ajax is that it provides instantaneous feedback to the user because it requests information asynchronously from the backend web server
 
 
 
                     ----------------Make JavaScript and CSS External:

Using external files in the real world generally produces faster pages because the JavaScript and CSS files are cached by the browser. JavaScript and CSS that are inlined in HTML documents get downloaded every time the HTML document is requested. This reduces the number of HTTP requests that are needed, but increases the size of the HTML document. On the other hand, if the JavaScript and CSS are in external files cached by the browser, the size of the HTML document is reduced without increasing the number of HTTP requests.


                    --------------------Use get to ajax request:

POST is implemented in the browsers as a two-step process: sending the headers first, then sending data. So it's best to use GET, which only takes one TCP packet to send (unless you have a lot of cookies).
 
 
                    ------------------No 404s:

HTTP requests are expensive so making an HTTP request and getting a useless response (i.e. 404 Not Found) is totally unnecessary and will slow down the user experience without any benefit.



            ----------------------------Reduce Cookie Size:

HTTP cookies are used for a variety of reasons such as authentication and personalization. Information about cookies is exchanged in the HTTP headers between web servers and browsers. It's important to keep the size of cookies as low as possible to minimize the impact on the user's response time.


-----Reduce DNS Lookups

------Minify JavaScript and CSS

----Avoid Redirects

--------Remove Duplicate Scripts

----Configure Etags

----Make Ajax Cacheable

----Post-load Components

----Preload Components

---Reduce the Number of DOM Elements

----Minimize the Number of iframes

----Minimize DOM Access

----Optimize CSS Sprites

----Don't Scale Images in HTML

-----Make favicon.ico Small and Cacheable

------Avoid Empty Image src



==============================,lang attribute

The lang attribute specifies the language of the element's content.

Common examples are "en" for English, "es" for Spanish, "fr" for French, and so on.



=============================How to make page responsive?(,responsivePage)

Responsive Web Design is about using HTML and CSS to automatically resize, hide, shrink, or enlarge, a website, to make it look good on all devices (desktops, tablets, and phones).

1. Setting the viewport:

<meta name="viewport" content="width=device-width, initial-scale=1.0">

2. Responsive Images:

If the CSS width property is set to 100%, the image will be responsive and scale up and down

<img src="img.png" style="width:100%;">

3. Show different Images depending on Browser Width:

The HTML <picture> element allows you to define different images for different browser window sizes.

<picture>
  <source srcset="img_small.jpg" media="(max-width: 600px)">
  <source srcset="img_large.jpg" media="(max-width: 1500px)">
  <source srcset="img.jpg">
  <img src="img_small.jpg" alt="Image">
</picture>

4. Responsive Text Size:

The text size can be set with a "vw" unit, which means the "viewport width". That way the text size will follow the size of the browser window.

<h1 style="font-size:10vw">Hello World</h1>

5. Media Queries:

Using media queries you can define completely different styles for different browser sizes.

/* Use a media query to add a breakpoint at 800px: */
@media screen and (max-width: 800px) {
  .left, .main, .right {
    width: 100%; /* The width is 100%, when the viewport is 800px or smaller */
  }
}



=========================================How can I get indexed better by search engines?(,searchEngine)

HTML tags are used to influence the way our pages appear in search results. 
With the help of certain tags, we can turn regular search snippets into rich snippets, and maybe even into featured snippets. And, as our search snippets get more advanced, they are able to secure better Search Engine Results Pages (SERP) positions and attract more traffic.

Here are all the HTML tags that still matter:

1. Title tag:

Title tags are used by search engines to determine the subject of a page and display it in SERP. 
As a rule of thumb, titles that are under 60 characters long will fit on most screens. In HTML, a title tag looks like this:

<title>Your Title Goes Here</title>

2. Meta description tag:

Meta description is a short paragraph of text used to describe your page in search results. 
The function of meta description is similar to the title. It provides a little more detail about your page and it helps users decide whether to visit your page or not. 
In HTML, a meta description tag looks like this:

<meta name="description" content="Your description goes here">

3. Heading tags:

Headings (H1-H6) are used to split your page into sections or chapters. Each heading is like a small title within the page. 
In HTML, a heading looks like this:

<h1>Your heading goes here</h1>

4. Image alt attribute:

The alt text attribute is a part of an image tag, and it provides a description for an image. Alt text plays a major role in image optimization. 
It makes your images accessible both to search engines (by telling them what a particular image means) and to people 
    (by displaying an alternative text in case a particular image cannot be loaded or by helping screen readers convey images). In HTML it may look like this:

<img src="url" alt="Your image description goes here">

5. Open Graph tags:

Open Graph (OG) tags are placed in the <head> section of a page and allow any webpage to become a rich object in social networks. 
OG tags let you control how the information about your page is represented when shared via social channels. 
This possibility may help you enhance the performance of your links on social media, thus driving more click-throughs and increasing conversions. 
In HTML, it can look like this:

<meta name="og:title" property="og:title" content="Your Open Graph Title Goes Here">

6. Robots tag:

A robots tag is an element in the HTML of a page that informs search engines which pages on your site should be indexed and which should not. 
Its functions are similar to robots.txt, but robots.txt gives suggestions. Whereas robots tags give instructions. In HTML, it can look like this:

<meta name="robots" content="index, follow">

7. Canonical tag:

A canonical tag is a way of telling search engines that a specific URL represents the master copy of a page. 
Using the canonical tag prevents problems caused by identical or "duplicate" content appearing on multiple URLs. 
Practically speaking, the canonical tag tells search engines which version of a URL you want to appear in search results. In HTML, it may look like this:

<link href="URL" rel="canonical">

8. HTML5 semantic tags:

One of the most important features of HTML5 is its semantics tags. 
Semantic tags refers to syntax that makes the HTML more comprehensible by better defining the different sections and layout of web pages. 
It makes web pages more informative and adaptable, allowing browsers and search engines to better interpret content. 
For example, instead of using <div id="header"></div> you can use a <header></hrader> tag.



=====================attribute  ,vs property in HTML?

Attributes are defined by HTML. Properties are accessed from DOM (Document Object Model) nodes.

Example:

<input id="inputId" type="text" value="Hello World!" />
The value property reflects the current text-content inside the input box, whereas the value attribute contains the initial text-content of the value attribute from the HTML source code

Difference between HTML attributes and DOM properties:

                     Attribute	                                       Property

    Attributes are defined by HTML.	                         Properties are defined by the DOM.

    The value of an attribute is constant.	                 The value of a property is variable.

    These are used to initialize the DOM properties.	       No such job defined.



Example in JavaScript:

html
Copy code
<a id="myLink" href="https://www.example.com">Click me</a>
<script>
  // Accessing the href property of the anchor element in JavaScript
  var link = document.getElementById("myLink");
  console.log(link.href); // Outputs: https://www.example.com

  // Modifying the href property dynamically
  link.href = "https://www.newexample.com";
  console.log(link.href); // Outputs: https://www.newexample.com
</script>
In this example, href is both an attribute in the HTML markup and a property in the JavaScript code. The property can be dynamically modified during runtime.

In summary, attributes are part of the static HTML markup, while properties are part of the dynamic, runtime representation of HTML elements in the DOM. JavaScript allows you to manipulate properties, providing a way to interact with and modify the content and behavior of the page dynamically.



================== optional tag?(,optionalTags)


In HTML, tags like <header>, <footer>, and <nav> are not strictly necessary for a webpage to display content, but they provide semantic meaning and structure to the document. Including these tags can enhance the accessibility and SEO of the page, but they are optional in the sense that the page will still render without them.
The following lists all optional tags.

Tag	Description
<area>	
<base>	
<body>	
<br>	
<caption>	
<col>	
<colgroup>	
<dd>	
<dt>	
<embed>	
<head>	
<hr>	
<html>	
<img>	
<input>	
<li>	
<link>	
<meta>	
<optgroup>	
<option>	
<p>	
<param>	
<rp>	
<rt>	
<source>	
<tbody>	
<td>	
<tfoot>	
<th>	
<thead>	
<tr>	
<track>	
<wbr>


======================================What is an HTML preprocessor? Have you used different HTML templating languages before?(.preprocessorHtml)

A HTML preprocessor is a program that takes one type of data and converts it to another one. 
In case of HTML and CSS, some of the more popular preprocessor languages are Slim and Sass. Slim is processed into HTML and Sass is processed into CSS.

No, but I heard about html template language like PUG (formerly Jade), Haml, ERB, Slim, Handlebars, Jinja, Liquid etc 
   which is HTML preprocessor this mean that it is basically a language that will be converted to native html code.

The typical usage is when you render something on the server side. 
The usual use-case is when you have to add dynamic content to your website, so when you fetch something from your database, 
                    you will have to replace some parts in your original template.




==============================How do you change the direction of html text?

The default text direction in HTML is left-to-right. However, when developing web content and applications, we may need to set it to right-to-left, for instance, 
to cater for languages such as Arabic, Hebrew, Pashto, Persian, Urdu, and Sindhi.

We can set text direction in HTML in one of two ways:

With the HTML dir attribute
With the CSS direction property
Example:

<!-- Syntax -->
<element dir="ltr|rtl|auto">

<!-- Example -->
<textarea dir="rtl"></textarea>
Attribute Values:

Value	Description
ltr	Default. Left-to-right text direction
rtl	Right-to-left text direction
auto	Let the browser figure out the text direction, based on the content


================,standaloneComponents====

In Angular, standalone components are individual pieces of your user interface that can be developed, tested, and used independently. They are reusable building blocks that help you organize and modularize your application.


üîπ What it does:
Marks a component, directive, or pipe as standalone, meaning it doesn‚Äôt need to be declared in any NgModule.

üîπ Why it matters:
Traditionally, Angular components had to be declared in an NgModule. With standalone: true, you can skip this and use components directly ‚Äî making the code easier to organize, especially in small or modular apps.

imports: []
üîπ What it does:
Defines dependencies (like other standalone components, directives, pipes, or Angular modules) that this standalone component needs.

üîπ Used instead of:
imports in NgModules. With standalone components, this is placed directly in the component metadata.



==============,HTTP Interceptors in Angular(,httpInterceptors  ,interceptors)===
 HTTP interceptors in Angular are like middlemen that can intercept and modify HTTP requests or responses before they reach the server or after they come back from the server. They allow you to add common functionalities, such as authentication, logging, or error handling, to your HTTP requests.
 Real-Time Example:
Suppose you have an Angular application that communicates with a server to fetch data. You want to include a feature that automatically adds an authorization token to every outgoing request for authentication purposes.
Step 1: Create an Interceptor
        ng generate interceptor auth
Step 2: Implement the Interceptor
       
       in auth.interceptor.ts

import { Injectable } from '@angular/core';
import {
  HttpRequest,
  HttpHandler,
  HttpEvent,
  HttpInterceptor
} from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Add the authorization token to the request headers
    const modifiedRequest = request.clone({
      setHeaders: {
        Authorization: 'Bearer YourAuthTokenHere'
      }
    });

    // Pass the modified request to the next handler
    return next.handle(modifiedRequest);
  }
}


Step 3: Register the Interceptor in app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';

import { AppComponent } from './app.component';
import { AuthInterceptor } from './auth.interceptor';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, HttpClientModule],
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptor,
      multi: true
    }
  ],
  bootstrap: [AppComponent]
})
export class AppModule {}



============,lifecycle hooks==========
---------------,ngOnChanges--------------
// product-detail.component.ts
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-product-detail',
  template: `
    <div *ngIf="product">
      <h2>{{ product.name }}</h2>
      <p>Price: {{ product.price }}</p>
    </div>
  `,
})
export class ProductDetailComponent implements OnChanges {
  @Input() product: any;

  ngOnChanges(changes: SimpleChanges): void {
    if (changes.product) {
      console.log('Product changed:', changes.product.currentValue);
      // Perform additional actions when the product changes, e.g., fetch additional details
    }
  }
}

------------,ngDoCheck------------
export class ItemListComponent implements DoCheck {
  items: any[] = [
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    // ...
  ];

  ngDoCheck(): void {
    // Manual change detection logic
    // For demonstration purposes, we'll add an item to the list when the length is even
    if (this.items.length % 2 === 0) {
      this.items.push({ id: this.items.length + 1, name: `Item ${this.items.length + 1}` });
    }
  }
}
In this example:

The ItemListComponent has an array of items displayed using *ngFor.
Inside the ngDoCheck lifecycle hook, we're manually checking the length of the items array.
If the length is even, we add a new item to the list. This is a simplified example to demonstrate the manual change detection.

Explanation:
Default Change Detection:

By default, Angular runs change detection automatically and efficiently. However, in some cases, you might need to perform specific actions based on changes that Angular might not automatically detect.

ngDoCheck: Manual Change Detection:

The ngDoCheck lifecycle hook allows you to implement custom change detection logic.
In this example, we're checking the length of the items array.
If the length is even, we add a new item to the list, simulating a change that Angular might not detect automatically.
Use Cases:

Manual change detection can be useful in scenarios where you have specific conditions or changes that Angular's default mechanism might not capture.
It's crucial to use ngDoCheck judiciously to avoid unnecessary performance overhead.
Performance Considerations:

While ngDoCheck provides flexibility, it should be used carefully to prevent unnecessary checks and maintain optimal performance.


--------------,ngOnDestroy--------------
The ngOnDestroy lifecycle hook in Angular is called just before a directive or component is destroyed. It provides an opportunity to perform cleanup tasks, such as unsubscribing from observables, clearing intervals, or releasing resources.

Example: Cleaning Up Resources with ngOnDestroy
Let's consider a scenario where a component subscribes to an observable, and we want to make sure to unsubscribe when the component is about to be destroyed.




,gitHubInverview topics






=====,services======================== 
Services allow us to create reusable code and use it every component that needs it. 
The Services can be injected into components and other services using the dependency injection system.
 The dependencies are declared in the Module using the Provider‚Äôs metadata. The Angular creates a tree of injector & Providers that resembles the Component Tree.
  This is called the hierarchical pattern.

How to create a Service in Angular
An Angular service is simply a Javascript function. All we need to do is to create a class and add methods & properties. We can then create an instance of this class in our component and call its methods.

One of the best uses of services is to get the data from the data source. Let us create a simple service, which gets the product data and passes it to our component.


==========,bootstrapping module===========
Bootstrapping a module in the context of an Angular application refers to the process of launching and initializing the Angular framework for your application. It involves setting up the necessary infrastructure to run your Angular code, starting from a designated module.

In simpler terms:

Module Definition:

In Angular, your application is organized into modules. A module is a way to group related components, services, and other features of your application.
Root Module:

Every Angular application has a root module, which is the entry point of your application. This module is typically named AppModule.
Bootstrapping:

Bootstrapping is the act of telling Angular to start the application by loading and initializing the root module.
Bootstrap Module:

The term "bootstrap module" usually refers to the root module of your Angular application. It's the module that gets bootstrapped to start the entire application.
Main Entry Point:

In your Angular project, there's a file called main.ts. This file serves as the main entry point for your application, and its purpose is to bootstrap the root module.
So, in essence, bootstrapping a module in Angular means starting your application by initializing the root module, and this process is kicked off from the main.ts file. The root module defines the structure and dependencies of your application, and bootstrapping is the trigger that gets everything up and running.



==========,webPack=========
Webpack is a tool used in Angular (and many other modern web development projects) to help manage and bundle various files and assets used in your application. It takes different pieces of your code, like JavaScript, CSS, images, and more, and bundles them together into optimized and efficient packages for your web application.

Let's break down this explanation with a real-time example in the context of an Angular project:

Example Scenario:
Without Webpack:
Imagine you have an Angular application with multiple components, styles, and scripts. Each component has its own JavaScript file, styles are in separate CSS files, and you have images and fonts scattered around.

plaintext
Copy code
- app/
  - components/
    - header/
      - header.component.ts
      - header.component.css
    - main/
      - main.component.ts
      - main.component.css
  - assets/
    - images/
      - logo.png
    - fonts/
      - font.woff
Without a bundler like Webpack, your HTML might have to include multiple script and link tags for each component, style, image, and font, resulting in a lot of separate requests to the server.

With Webpack:
Configuration:

You set up a webpack.config.js file in your project to configure how Webpack should handle different types of files.
Dependency Graph:

Webpack creates a dependency graph by analyzing your code and figuring out how different files depend on each other.
Bundling:

It bundles everything together. For instance, it combines all your component files, styles, images, and fonts into a few optimized files.
Output:

The output is typically one or more JavaScript bundles, along with other optimized assets.
plaintext
Copy code
- dist/
  - bundle.js
  - styles.css
  - images/
    - logo.png
  - fonts/
    - font.woff
Efficiency:
With Webpack, your application becomes more efficient because it reduces the number of requests needed to load your app. Users download fewer and optimized files, resulting in faster load times.
Summary:
So, in a nutshell, Webpack is like a smart organizer for your web application, helping you manage and bundle all the pieces of your code and assets efficiently. It simplifies the development process and enhances the performance of your Angular application by creating optimized bundles that are ready to be served to users.






ROUTING

                1.What is ,Routing
Routing allows you to move from one part of the application to another part or one View to another View


               2.Angular ,Router Module
The Router is a separate module in Angular. It is in its own library package, @angular/router. The Router Module provides the necessary service providers and directives for navigating through application views.

Using Angular Router you can

Navigate to a specific view by typing a URL in the address bar
Pass optional parameters to the View
Bind the clickable elements to the View and load the view when the user performs application tasks
Handles back and forward buttons of the browser
Allows you to dynamically load the view
Protect the routes from unauthorized users using Guards


import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }




               3.Components of Angular ,Router Module
Router
Route
Routes
RouterOutlet
RouterLink
RouterLinkActive
ActivatedRoute
RouterState
RouteLink Parameters array

 1. Router:

The router is a module in Angular that provides a way to navigate between different components of an Angular application based on the URL.
typescript
Copy code
// Import the router module
import { RouterModule, Routes } from '@angular/router';

// Define routes
const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent },
];

// Add the RouterModule to your application
@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

2. Route:

A route defines a mapping between a URL path and a component in your Angular application.
typescript
Copy code
const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent },
];


3. Routes:

Routes is an array of Route objects that define the navigation paths and corresponding components.
typescript
Copy code
const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent },
];


4. RouterOutlet:

RouterOutlet is a directive in Angular that acts as a placeholder where the router displays the routed component views.
html
Copy code
<router-outlet></router-outlet>


5. RouterLink:

RouterLink is a directive in Angular used to create navigation links in your templates.
html
Copy code
<a routerLink="/home">Home</a>
<a routerLink="/about">About</a>


6. RouterLinkActive:

RouterLinkActive is a directive in Angular that adds a CSS class when the associated RouterLink is active.
html
Copy code
<a routerLink="/home" routerLinkActive="active">Home</a>
<a routerLink="/about" routerLinkActive="active">About</a>


7. ActivatedRoute:

ActivatedRoute is a service in Angular that provides information about the route that is currently active.
typescript
Copy code
import { ActivatedRoute } from '@angular/router';

constructor(private route: ActivatedRoute) { }

ngOnInit() {
  this.route.params.subscribe(params => {
    // Access route parameters
    console.log(params.id);
  });
}


8. RouterState:

RouterState is a service in Angular that represents the state of the router at a point in time.
typescript
Copy code
import { Router } from '@angular/router';

constructor(private router: Router) { }

ngOnInit() {
  const routerState = this.router.routerState;
  console.log(routerState);
}


9. RouteLink Parameters array:

Route parameters allow you to pass data to a route. You can access these parameters using the ActivatedRoute service.
typescript
Copy code
// Define a route with a parameter
const routes: Routes = [
  { path: 'user/:id', component: UserComponent },
];

// Access route parameter in component
import { ActivatedRoute } from '@angular/router';

constructor(private route: ActivatedRoute) { }

ngOnInit() {
  this.route.params.subscribe(params => {
    console.log(params.id); // Access the 'id' parameter
  });
}




=========4 ,How to configure Angular Router
->To Configure the Router in Angular, you need to follow these steps

->Set the <base href>
ex:<base href="/">
->Define routes for the view
ex:const appRoutes={ path: 'product', component: ProductComponent }
->Register the Router Service with Routes
ex:import { RouterModule } from '@angular/router';
   imports: [RouterModule.forRoot(routes)],
             in root module
->Map HTML Element actions to Route
  Next, we need to bind the click event of the link, image or button to a route. This is done using the routerlink directive
  <li><a [routerLink]="['product']">Product</a></li>
->Choose where you want to display the view
ex:<router-outlet></router-outlet>




  practical

  =create required comonents
  =create Routes array in app routing
  =<li><a [routerLink]="['home']">Home</a></li>
  =<router-outlet></router-outlet>




=========different angular versions you worked and there differences====


========,wildcard===
**





=======,patchMatch: 'full'  ,vs ,pathMatch: 'prefix'


üß† What is pathMatch: 'full'?
It tells Angular to match the entire URL path exactly with the route‚Äôs path. If the URL only partially matches, the route is ignored.

‚úÖ Example 1: Correct Use of pathMatch: 'full'
ts
Copy
Edit
// app-routing.module.ts
const routes: Routes = [
  { path: '', redirectTo: 'home', pathMatch: 'full' },  // ‚úÖ only matches when URL is exactly ''
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent }
];
What happens:
URL	Result
/	Redirects to /home (because it's full match for '')
/home	Loads HomeComponent
/about	Loads AboutComponent
/abc	No match ‚Üí shows blank or 404

‚ùå Example 2: Missing pathMatch: 'full' (wrong behavior)
ts
Copy
Edit
const routes: Routes = [
  { path: '', redirectTo: 'home' },  // ‚ö†Ô∏è uses default 'prefix'
  { path: 'home', component: HomeComponent }
];
Why it's bad:
Default pathMatch is 'prefix', so every path starts with ''.

So even /home matches path: '' ‚Üí redirect happens ‚Üí infinite redirect loop!

üß™ Difference Between 'prefix' and 'full'
üëâ Using pathMatch: 'prefix'
ts
Copy
Edit
{ path: '', redirectTo: 'home', pathMatch: 'prefix' }
Matches:

/

/home

/home/details

/anything ‚Üê still matches!

‚ö†Ô∏è This causes redirect loops or unexpected behavior.

üëâ Using pathMatch: 'full'
ts
Copy
Edit
{ path: '', redirectTo: 'home', pathMatch: 'full' }
Matches only:

/

Does NOT match:

/home

/home/details

/anything

‚úÖ Prevents redirect loops!

üß© Real-world Scenario: Redirect empty path to login
ts
Copy
Edit
const routes: Routes = [
  { path: '', redirectTo: 'login', pathMatch: 'full' },
  { path: 'login', component: LoginComponent },
  { path: 'dashboard', component: DashboardComponent }
];
Behavior:
Visiting http://localhost:4200/ ‚Üí redirects to /login

Visiting http://localhost:4200/login ‚Üí shows login page

Visiting http://localhost:4200/dashboard ‚Üí shows dashboard

‚úÖ Summary
When you want to...	Use pathMatch: 'full'?
Redirect from the empty path ('')	‚úÖ Yes
Match only when entire path is exactly ''	‚úÖ Yes
Match when URL starts with a prefix	‚ùå Use 'prefix' instead












Route Guards in Angular   =====,guards===================,routeGuards============



Angular provides 5 types of route guards:

Guard Type	Purpose
CanActivate	Check before activating a route
CanActivateChild	Check before activating a child route
CanDeactivate	Check before leaving a route
CanLoad	Check before loading lazy-loaded modules
CanMatch (Angular 15+)	Check if a route can be matched dynamically





üîê 1. CanActivate
‚úÖ What it does:
Determines if a route can be accessed (activated).

üì¶ When to use:
Use it to protect routes from unauthorized access (like requiring login).

üîß How to implement:
a. Generate the guard:
bash
Copy
Edit
ng generate guard auth
b. AuthGuard code (auth.guard.ts):
ts
Copy
Edit
@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(): boolean {
    if (this.authService.isLoggedIn()) {
      return true;
    } else {
      this.router.navigate(['/login']);
      return false;
    }
  }
}
c. Apply to route:
ts
Copy
Edit
{ path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] }


üë∂ 2. CanActivateChild
‚úÖ What it does:
Checks if child routes of a parent route can be activated.

üì¶ When to use:
When you want to protect all children under a route, like admin pages.

üîß How to implement:
a. Guard code:
ts
Copy
Edit
@Injectable({ providedIn: 'root' })
export class ChildGuard implements CanActivateChild {
  constructor(private authService: AuthService, private router: Router) {}

  canActivateChild(): boolean {
    return this.authService.hasRole('admin');
  }
}
b. Apply to parent route:
ts
Copy
Edit
{
  path: 'admin',
  component: AdminLayoutComponent,
  canActivateChild: [ChildGuard],
  children: [
    { path: 'users', component: UserListComponent },
    { path: 'settings', component: SettingsComponent }
  ]
}


üîÑ 3. CanDeactivate
‚úÖ What it does:
Checks if the user can leave a route/component.

üì¶ When to use:
To warn users about unsaved form data before navigating away.

üîß How to implement:
a. Create interface:
ts
Copy
Edit
export interface CanComponentDeactivate {
  canDeactivate: () => boolean | Observable<boolean>;
}
b. Component should implement it:
ts
Copy
Edit
export class EditProfileComponent implements CanComponentDeactivate {
  hasUnsavedChanges = true;

  canDeactivate(): boolean {
    return !this.hasUnsavedChanges || confirm("Leave without saving?");
  }
}
c. Guard code:
ts
Copy
Edit
@Injectable({ providedIn: 'root' })
export class DeactivateGuard implements CanDeactivate<CanComponentDeactivate> {
  canDeactivate(component: CanComponentDeactivate): boolean | Observable<boolean> {
    return component.canDeactivate();
  }
}
d. Apply to route:
ts
Copy
Edit
{ path: 'edit-profile', component: EditProfileComponent, canDeactivate: [DeactivateGuard] }



üß© 4. CanLoad
‚úÖ What it does:
Checks if a lazy-loaded module can be loaded before it's even downloaded.

üì¶ When to use:
When you want to prevent unauthorized users from loading the entire module (not just route access).

üîß How to implement:
a. Guard code:
ts
Copy
Edit
@Injectable({ providedIn: 'root' })
export class LoadGuard implements CanLoad {
  constructor(private authService: AuthService, private router: Router) {}

  canLoad(): boolean {
    const loggedIn = this.authService.isLoggedIn();
    if (!loggedIn) this.router.navigate(['/login']);
    return loggedIn;
  }
}
b. Apply to lazy route:
ts
Copy
Edit
{ 
  path: 'admin', 
  loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule), 
  canLoad: [LoadGuard] 
}



üßÆ 5. CanMatch (Angular 15+)
‚úÖ What it does:
Checks if a route should be matched at all.

üì¶ When to use:
Use it for feature flags, A/B testing, or conditional matching.

üîß How to implement:
a. Guard code:
ts
Copy
Edit
@Injectable({ providedIn: 'root' })
export class FeatureGuard implements CanMatch {
  constructor(private featureService: FeatureToggleService) {}

  canMatch(): boolean {
    return this.featureService.isFeatureEnabled('new-dashboard');
  }
}
b. Apply to route:
ts
Copy
Edit
{ 
  path: 'dashboard',
  canMatch: [FeatureGuard],
  loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule)
}
üîí Auth Guard
‚úÖ What it is:
An authentication/authorization guard (usually implemented using CanActivate or CanLoad).

üîß How to implement:
Same as the AuthGuard shown in CanActivate above. You can also check roles, permissions, or token expiry.


‚úÖ Final Summary Table
Guard	Checks if...	Best for...
CanActivate	You can enter a route	Auth checks for routes
CanActivateChild	You can enter child routes	Securing child admin routes
CanDeactivate	You can leave a component	Preventing unsaved changes loss
CanLoad	A lazy-loaded module can load	Blocking download of admin modules
CanMatch	A route should even be considered	Feature toggles / experimental flows
AuthGuard	You're authenticated/authorized	Custom login + role validation



CanLoad is more security-focused to ensure modules aren't even downloaded if access is denied.

CanMatch is more flexible and suitable for redirects, dynamic decisions, and route param logic.

In Angular 15+, CanMatch is often recommended over CanLoad for better routing control and UX.














==================
To get dynamic route parameters (IDs) from the URL in Angular, you can use the ActivatedRoute service from @angular/router.

‚úÖ Step-by-step: Get Dynamic ID from URL
üîó Example URL:
bash
Copy
Edit
/user/123
üõ£Ô∏è Route Configuration (app-routing.module.ts):
ts
Copy
Edit
const routes: Routes = [
  { path: 'user/:id', component: UserComponent }
];
üë®‚Äçüíª In UserComponent.ts:
ts
Copy
Edit
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-user',
  template: `<p>User ID: {{ userId }}</p>`
})
export class UserComponent implements OnInit {
  userId: string | null = null;

  constructor(private route: ActivatedRoute) {}

  ngOnInit(): void {
    this.userId = this.route.snapshot.paramMap.get('id'); // Get static value
    // Or dynamically listen for changes:
    // this.route.paramMap.subscribe(params => {
    //   this.userId = params.get('id');
    // });
  }
}
üí° Alternate: Using paramMap Observable (for dynamic updates):
ts
Copy
Edit
this.route.paramMap.subscribe(params => {
  this.userId = params.get('id');
});
üß™ Output for /user/123
sql
Copy
Edit
User ID: 123
‚úÖ Also get Query Params from URL
If the URL is /user/123?active=true:

ts
Copy
Edit
this.route.queryParamMap.subscribe(params => {
  const isActive = params.get('active'); // true
});
üîÅ Summary
Use	Code Example
Get route param (e.g., :id)	this.route.snapshot.paramMap.get('id')
Observe param changes	this.route.paramMap.subscribe(...)
Get query param (e.g. ?q=abc)	this.route.snapshot.queryParamMap.get('q')

Let me know if you‚Äôre using child routes or router outlets, I can help with nested route parameter handling too.








You said:
activated route,snapshot,queryparams


ChatGPT said:
Let's break down ActivatedRoute, snapshot, and queryParams in Angular clearly with definitions, examples, and differences.

üîç 1. ActivatedRoute ‚Äî What Is It?
A service that provides access to the current route information: route parameters, query params, data, fragment, etc.

Injected in a component to access URL values when the route is active.

‚úÖ Import and Inject:
ts
Copy
Edit
import { ActivatedRoute } from '@angular/router';

constructor(private route: ActivatedRoute) {}
üìç 2. snapshot vs observable (live changes)
Feature	snapshot	observable (e.g., paramMap.subscribe)
Type	Static value at the time of component load	Reactive, listens for changes
Usage	Good when the route won‚Äôt change	Best for watching dynamic route changes
Use case	/user/123 ‚Üí component loads once	URL changes but same component instance

üìå Route Param Example
‚úÖ URL
bash
Copy
Edit
/user/123
‚úÖ Route Config
ts
Copy
Edit
{ path: 'user/:id', component: UserComponent }
‚úÖ In Component
a. Using snapshot (simple case):
ts
Copy
Edit
ngOnInit() {
  const userId = this.route.snapshot.paramMap.get('id');  // "123"
}
b. Using Observable (detect changes):
ts
Copy
Edit
ngOnInit() {
  this.route.paramMap.subscribe(params => {
    const userId = params.get('id');  // updates if route param changes
  });
}
‚ùì What is queryParams
Query params are optional key/value pairs in the URL after ?.

‚úÖ URL
bash
Copy
Edit
/user/123?tab=profile&active=true
‚úÖ Reading Query Params
a. With snapshot:
ts
Copy
Edit
ngOnInit() {
  const tab = this.route.snapshot.queryParamMap.get('tab'); // "profile"
  const active = this.route.snapshot.queryParamMap.get('active'); // "true"
}
b. Using Observable:
ts
Copy
Edit
ngOnInit() {
  this.route.queryParamMap.subscribe(params => {
    const tab = params.get('tab');     // "profile"
    const active = params.get('active'); // "true"
  });
}
üîÅ Summary Table
What	API	Use For
Route Params	route.snapshot.paramMap.get('id')	/user/:id
Query Params	route.snapshot.queryParamMap.get('q')	/search?q=cat
Live Params	route.paramMap.subscribe(...)	When route param changes in same component
Live Query Params	route.queryParamMap.subscribe(...)	Watch query param changes (e.g., filters)

üéØ Pro Tip: Combine Route and Query Params
ts
Copy
Edit
this.route.paramMap.subscribe(routeParams => {
  const id = routeParams.get('id');
  
  this.route.queryParamMap.subscribe(queryParams => {
    const filter = queryParams.get('filter');
  });
});
Let me know if you want an example with child routes, nested routes, or how to set query params using Router.navigate().








You said:
Router.navigate(). and Router.navigateByUrl()


ChatGPT said:
Great! Let's explore the difference between Router.navigate() and Router.navigateByUrl() in Angular routing with examples, use cases, and when to use each.

üß≠ 1. Router.navigate() ‚Äî Navigate by Route Commands Array
‚úÖ Syntax:
ts
Copy
Edit
this.router.navigate(['/path', param], { queryParams: { key: 'value' } });
üß† Use When:
You want to construct a route relative to the current one

You want to add query parameters or fragments easily

Works well with dynamic route building

‚úÖ Example:
ts
Copy
Edit
this.router.navigate(['/user', 123], {
  queryParams: { tab: 'profile' }
});
// Navigates to: /user/123?tab=profile
With relative navigation:
ts
Copy
Edit
this.router.navigate(['edit'], { relativeTo: this.route });
// If current route is /user/123 ‚Üí navigates to /user/123/edit
üåê 2. Router.navigateByUrl() ‚Äî Navigate by URL string
‚úÖ Syntax:
ts
Copy
Edit
this.router.navigateByUrl('/path?query=value');
üß† Use When:
You already have a full URL as a string

You want to paste in a known URL

Less flexible for dynamic or relative routes

‚úÖ Example:
ts
Copy
Edit
this.router.navigateByUrl('/user/123?tab=profile');
// Same as above, but written as full URL
üîÅ Summary Table
Feature	navigate()	navigateByUrl()
Input type	Array of route segments	Full URL string
Supports route building	‚úÖ Yes	‚ùå No
Supports relative navigation	‚úÖ Yes	‚ùå No
Supports queryParams object	‚úÖ Yes	‚ùå Must include in URL string
Common use case	Dynamic paths, reusable routes	Fixed URLs, redirection logic

üîÑ Example Comparison
With navigate():
ts
Copy
Edit
this.router.navigate(['/user', userId], {
  queryParams: { active: true }
});
With navigateByUrl():
ts
Copy
Edit
this.router.navigateByUrl(`/user/${userId}?active=true`);
Both go to: /user/123?active=true, but navigate() gives you better structure and options.

üí° Pro Tip:
If you need navigation with complex logic (fragments, query params, relative paths), prefer navigate().
If you have a fixed path (e.g., redirect after login), navigateByUrl() is simple and clean.

Let me know if you want to navigate programmatically with replaceUrl, skipLocationChange, or navigate on router events!








You said:
relative route


ChatGPT said:
‚úÖ What is a Relative Route in Angular?
A relative route is a route that is relative to the current activated route ‚Äî instead of using an absolute path (/), you base your navigation from where you currently are in the route tree.

üß≠ Absolute vs Relative Routing
Type	Example	Description
Absolute	/products/edit	Always starts from the root /
Relative	edit (from /products/1)	Appends to the current route

üîß Basic Setup
üìÅ Route Config (e.g., app-routing.module.ts):
ts
Copy
Edit
const routes: Routes = [
  {
    path: 'products',
    component: ProductsComponent,
    children: [
      { path: ':id', component: ProductDetailComponent },
      { path: ':id/edit', component: EditProductComponent }
    ]
  }
];
üë®‚Äçüíª Example: Navigate to a Relative Route
Suppose you're in the URL /products/1, and you want to go to /products/1/edit.

In ProductDetailComponent.ts:
ts
Copy
Edit
import { ActivatedRoute, Router } from '@angular/router';

constructor(private router: Router, private route: ActivatedRoute) {}

goToEdit() {
  this.router.navigate(['edit'], { relativeTo: this.route });
}
üß† What this does:
'edit' is appended to the current route, which is /products/1

Navigates to: /products/1/edit

üß™ Another Example: Go Up One Level
If you're in /products/1/edit and want to go back to /products/1:

ts
Copy
Edit
this.router.navigate(['../'], { relativeTo: this.route });
// or go back to product list:
this.router.navigate(['../../'], { relativeTo: this.route });
üìå Why Use Relative Routing?
‚úÖ Cleaner route building in nested routes
‚úÖ Helps in modular components where route context matters
‚úÖ Useful in child components and router outlets

üß† Summary
Goal	Code
Navigate to a child	this.router.navigate(['edit'], { relativeTo })
Go back one level	this.router.navigate(['../'], { relativeTo })
Go back two levels	this.router.navigate(['../../'], { relativeTo })
Use absolute route	this.router.navigate(['/products'])
















================,viewencapctulation

‚úÖ What is ViewEncapsulation?
It is an Angular API that determines whether styles defined in a component should:

Apply only to that component‚Äôs template

Leak out to the global DOM

Be globally applied to everything

Angular provides 3 encapsulation strategies to control this.  

üß± Types of ViewEncapsulation
1. Emulated (default)
Emulates Shadow DOM behavior using scoped CSS via attribute selectors.

‚úÖ Styles apply only to the component
‚ùå Styles do not affect other components

üîß Angular adds unique attributes like _ngcontent-abc to scope styles

css
Copy
Edit
/* example.component.css */
h1 {
  color: red;
}
üëÄ Compiles to:

html
Copy
Edit
<h1 _ngcontent-abc>Red title</h1>
‚úÖ Best for typical component isolation
‚úÖ Cross-browser support

2. None
No encapsulation ‚Äî styles are global.

‚úÖ Styles apply everywhere in the app
‚ùå Can cause style conflicts between components

üîß Angular does not scope styles at all.

ts
Copy
Edit
encapsulation: ViewEncapsulation.None
üìå Use it when:

You want shared global styles from a component

You're working with global themes or resets

3. ShadowDom
Uses the native browser Shadow DOM API for true encapsulation.

‚úÖ Full style isolation using real Shadow DOM
‚úÖ Styles never leak in or out

‚ùå Not supported in IE 11 and older browsers
‚ùå Debugging can be tricky

ts
Copy
Edit
encapsulation: ViewEncapsulation.ShadowDom
üëÄ Creates:

html
Copy
Edit
<app-example>
  #shadow-root
    <h1>Shadow DOM content</h1>
</app-example>
üìå Use it when:

You want full isolation (like Web Components)

You‚Äôre targeting modern browsers only




‚öîÔ∏è Emulated vs ShadowDom ‚Äî Key Differences
Feature	Emulated (Default)	     ShadowDom
Encapsulation type	Emulates style scoping using attributes	Native browser-based Shadow DOM
Style leakage	‚ùå No (scoped with _ngcontent-xyz)	‚ùå No (truly isolated)
Global styles apply inside?	‚úÖ Yes (like Bootstrap, Material, etc.)	‚ùå No (unless manually exposed via ::part)
Browser support	‚úÖ All browsers including IE11	‚ùå Modern browsers only (Chrome, Edge, Firefox)
Debugging/DevTools	‚úÖ Easy (styles visible in main DOM)	‚ö†Ô∏è Harder (styles hidden in shadow root)
Custom styling from outside	‚úÖ Yes (target with selectors)	‚ùå Not directly (requires ::part, ::slotted)












===============================


üî∂ ng-content ‚Äì For Content Projection
‚úÖ What It Does:
<ng-content> is used to project content from a parent component into a child component ‚Äî like a placeholder for external content.

üß± Use Case: Reusable components like cards, modals, tabs, etc.
üëá Parent uses:
html
Copy
Edit
<app-card>
  <h1>Title from parent</h1>
  <p>This paragraph is projected!</p>
</app-card>
üëá Child component (app-card.component.html):
html
Copy
Edit
<div class="card">
  <ng-content></ng-content>
</div>
üß™ Output:
html
Copy
Edit
<div class="card">
  <h1>Title from parent</h1>
  <p>This paragraph is projected!</p>
</div>
üéØ When to use:
You want to allow custom content inside your component

You're building wrapper or container components (like mat-card, apac-label, etc.)

üß© Bonus: Named slots with select
html
Copy
Edit
<!-- Child component -->
<ng-content select="header"></ng-content>
<ng-content select="main"></ng-content>
html
Copy
Edit
<!-- Parent usage -->
<app-card>
  <header>Header here</header>
  <main>Main content</main>
</app-card>
üî∑ ng-template ‚Äì For Template Storage & Reuse
‚úÖ What It Does:
<ng-template> is used to define HTML blocks that are not rendered by default ‚Äî they're only rendered when Angular explicitly tells it to render.

üîß Use Case: Conditional templates, custom rendering, *ngIf, ngTemplateOutlet, ngFor
üëá Example 1: ngIf with ng-template
html
Copy
Edit
<div *ngIf="isLoggedIn; else loginTemplate">
  Welcome back!
</div>

<ng-template #loginTemplate>
  Please log in.
</ng-template>
üëá Example 2: ngTemplateOutlet
html
Copy
Edit
<ng-template #greet let-name="name">
  <p>Hello, {{ name }}!</p>
</ng-template>

<ng-container *ngTemplateOutlet="greet; context: { name: 'Siva' }"></ng-container>
üîÅ ng-content vs ng-template ‚Äî Key Differences
Feature	ng-content	ng-template
Purpose	Projects parent content into child	Stores template for conditional/dynamic rendering
When it renders	Always (if content exists)	Only when conditionally triggered
Used in reusable components?	‚úÖ Yes	‚úÖ Yes
Syntax	<ng-content></ng-content>	<ng-template #tpl></ng-template>
Use with *ngIf, *ngFor	‚ùå No	‚úÖ Yes













=========================================What is Redux?

Redux is a state management library for JavaScript applications (commonly used with React, but can be used with Angular, Vue, etc.).
It helps manage the global state of your application in a predictable way.

üîπ Why do we need Redux?

Imagine you‚Äôre building a shopping cart app:

The cart icon in the header should show how many items are in the cart.

The cart page should list all items.

The checkout page should know the total price.

If you pass data (props) between components manually, it becomes messy ("prop drilling").
Redux solves this by keeping a single source of truth: a store that holds your app‚Äôs state.

üîπ Redux Core Concepts

Store

The central place where the state lives.

Example: The "shopping cart" data is stored here.

State

The actual data inside the store.

Example:

{
  cartItems: [{ id: 1, name: "Shoes", qty: 2 }],
  user: { name: "John", loggedIn: true }
}


Action

A plain JavaScript object that describes what you want to do.

Example: Add an item to cart:

{ type: "ADD_TO_CART", payload: { id: 2, name: "Watch", qty: 1 } }


Reducer

A pure function that takes the current state + action ‚Üí returns a new state.

Example:

function cartReducer(state = [], action) {
  switch (action.type) {
    case "ADD_TO_CART":
      return [...state, action.payload];
    default:
      return state;
  }
}


Dispatch

The way to send an action to the store.

Example:

store.dispatch({ type: "ADD_TO_CART", payload: { id: 3, name: "Bag", qty: 1 } });


Subscriber

Components subscribe to the store to get updated state.

Example: The cart icon re-renders when a new item is added.

üîπ Redux Flow (Step by Step)

User clicks "Add to Cart".

An Action ({ type: "ADD_TO_CART", payload: {...} }) is created.

The Dispatch sends this action to the Store.

The Reducer checks the action type and updates the State.

The new State goes back to the Store.

All Subscribers (components) update automatically.

üîπ Real-Life Example (ATM Machine analogy)

Store (State) = ATM balance (‚Çπ5000).

Action = "WITHDRAW 1000".

Reducer = Calculates new balance (5000 - 1000 = 4000).

Dispatch = You press the withdraw button.

Subscriber = Screen updates to show ‚Çπ4000.

‚úÖ In short:
Redux = Store + Actions + Reducers + Dispatch + Subscribers.






=====================================Perfect üëç Let‚Äôs go step by step with a small Angular + NgRx (Redux for Angular) example.

We‚Äôll build a simple counter app with Redux in Angular.

üîπ Step 1: Install NgRx

Run in your Angular project:

ng add @ngrx/store

üîπ Step 2: Create Counter State
counter.actions.ts
import { createAction } from '@ngrx/store';

export const increment = createAction('[Counter] Increment');
export const decrement = createAction('[Counter] Decrement');
export const reset = createAction('[Counter] Reset');

counter.reducer.ts
import { createReducer, on } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';

export const initialState = 0;

export const counterReducer = createReducer(
  initialState,
  on(increment, (state) => state + 1),
  on(decrement, (state) => state - 1),
  on(reset, () => 0)
);

üîπ Step 3: Register Reducer in App Module
app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { StoreModule } from '@ngrx/store';
import { counterReducer } from './counter.reducer';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    StoreModule.forRoot({ count: counterReducer })  // <-- Register store
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}

üîπ Step 4: Use Store in Component
app.component.ts
import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  count$ = this.store.select('count');  // observable of state

  constructor(private store: Store<{ count: number }>) {}

  onIncrement() {
    this.store.dispatch(increment());
  }

  onDecrement() {
    this.store.dispatch(decrement());
  }

  onReset() {
    this.store.dispatch(reset());
  }
}

app.component.html
<div style="text-align:center; margin-top:50px">
  <h1>Angular + Redux Counter</h1>
  
  <h2>Count: {{ count$ | async }}</h2>

  <button (click)="onIncrement()">Increment</button>
  <button (click)="onDecrement()">Decrement</button>
  <button (click)="onReset()">Reset</button>
</div>

üîπ Step 5: Run the App
ng serve


‚úÖ You‚Äôll see a counter with Increment / Decrement / Reset buttons ‚Äî all managed by Redux store.







 ============================ angular folder structure

 ----------------->

 1. src/ folder

This is the main source folder where your app code lives.

index.html ‚Äì The main HTML file that loads your Angular app. Angular injects your app‚Äôs components here.

styles.css (or .scss) ‚Äì Global styles for your application.

main.ts ‚Äì Entry point of the Angular app. Bootstraps the root module.

polyfills.ts ‚Äì Compatibility code for older browsers.

app/ folder ‚Äì Contains your application-specific code:

app.component.ts ‚Äì The root component of the app.

app.component.html ‚Äì Template (HTML) for the root component.

app.component.css (or .scss) ‚Äì Styles for the root component.

app.module.ts ‚Äì Root module that declares components and imports other modules.

Other components, services, and modules you create.

assets/ ‚Äì Folder to store static files like images, icons, JSON files, etc.

environments/ ‚Äì Contains configuration files for different environments:

environment.ts ‚Äì Development environment configuration.

environment.prod.ts ‚Äì Production environment configuration.

2. Root project files

angular.json ‚Äì Angular CLI configuration file. Defines project settings, build options, assets, styles, and scripts.

package.json ‚Äì Lists all dependencies and scripts to run the app. Contains metadata like app name and version.

package-lock.json ‚Äì Auto-generated file that locks package versions to ensure consistent installs.

tsconfig.json ‚Äì TypeScript configuration file. Tells TypeScript how to compile your .ts files.

tsconfig.app.json ‚Äì TypeScript configuration specific to the Angular app.

tsconfig.spec.json ‚Äì TypeScript configuration for unit tests.

karma.conf.js ‚Äì Configuration for Karma test runner (for unit tests).

browserslist ‚Äì Defines which browsers your app should support.

.editorconfig ‚Äì Optional file that maintains consistent coding style across editors.

.gitignore ‚Äì Lists files/folders Git should ignore (like node_modules/).

README.md ‚Äì Project instructions on how to install and run the app.



------------------------------>


1. src/ folder

This is the main source folder where all your app code lives. Changing anything here directly affects your app.

------------------------------->

üß© What is index.html in Angular?

The index.html file is the main HTML file that acts as the entry point for your Angular application.
When you run ng serve or build your app, this is the first file the browser loads.

Typical content:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>MyApp</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <app-root></app-root>
  </body>
</html>

<head> ‚Üí includes meta info (title, charset, viewport, favicon)

<body> ‚Üí has one special tag: <app-root>


What happens if you change:

<title> ‚Üí Changes the title shown in the browser tab.

<base href="/"> ‚Üí Important for routing. Changing it incorrectly can break navigation.

<app-root> ‚Üí Changing this selector breaks your app bootstrap (Angular won‚Äôt know where to render).



What <app-root> Does

<app-root> is a custom Angular component selector.

When the Angular app starts, the framework:

Loads main.ts.

Bootstraps the AppModule.

Finds the AppComponent.

Replaces <app-root> in index.html with the HTML from app.component.html.

üí° So basically, index.html is just a shell ‚Äî Angular fills it with the real content dynamically.

üèóÔ∏è Why It‚Äôs Needed

It‚Äôs the starting point for the Angular app.

It provides a container (<app-root>) for the Angular component tree.

It defines global metadata (like title, favicon, responsive design).

It‚Äôs the file where Angular injects all compiled scripts and styles during build (scripts.js, styles.css).

‚ö° Example Flow

Browser loads index.html.

Angular loads scripts.

Framework finds <app-root>.

AppComponent replaces it with dynamic content.

Application becomes visible and interactive.

In short:
üëâ index.html is the entry HTML file that loads first, defines the page shell, and tells Angular where to insert the root component (<app-root>).






--------------------------------->

styles.css (or styles.scss)

Purpose: Global styles applied to the whole app.

Example:

body {
  margin: 0;
  font-family: Arial, sans-serif;
  background-color: #f5f5f5;
}


What happens if you change:

body styles ‚Üí Changes the look of the entire app.

Adding classes ‚Üí Makes them available in any component without importing separately.


-------------------------------------->

main.ts

Purpose: Entry point. Bootstraps the root module.

Example:

import { enableProdMode } from '@angular/core';
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';
import { environment } from './environments/environment';

if (environment.production) {
  enableProdMode();
}

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));  


What happens if you change:

Change AppModule ‚Üí Boots a different module.

Remove bootstrap line ‚Üí App will not start.

Add extra code before bootstrap ‚Üí Can run initialization logic (like setting global variables).


------------------------>

polyfills.ts

Purpose: Compatibility with older browsers.

Typical content:

import 'zone.js';  // Required by Angular


What happens if you change:

Remove zone.js ‚Üí App may fail because Angular relies on zones for change detection.

Add other polyfills ‚Üí Lets your app work in IE11 or older browsers.

app/ folder

Contains all application-specific code.



------------------------>

app.module.ts

Purpose: Root module. Declares components, imports modules, provides services.

Typical content:

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}


What happens if you change:

Add a component in declarations ‚Üí Angular can use it in templates.

Add a module in imports ‚Üí You can use features from that module.

Change bootstrap ‚Üí Boots a different component as root.

Remove BrowserModule ‚Üí App won‚Äôt render in a browser.


----------------------->

app.component.ts

Purpose: Root component logic. Contains properties, functions, and bindings.

Example:

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'My Angular App';
}


What happens if you change:

selector ‚Üí <app-root> in index.html must match, or app won‚Äôt render.

title ‚Üí Changes what‚Äôs displayed if used in template with {{ title }}.

Add methods ‚Üí Can be called in template for event handling.




----------------------->

app.component.html

Purpose: Template for the root component.

Example:

<h1>Welcome to {{ title }}</h1>
<router-outlet></router-outlet>


What happens if you change:

Change {{ title }} ‚Üí Updates displayed text.

Add <router-outlet> ‚Üí Required for routing views.

Remove <router-outlet> ‚Üí Routes will not display.



<header>My App Header</header>

<!-- Dynamic content based on route -->
<router-outlet></router-outlet>

<footer>My App Footer</footer>

Here:

Header and footer stay fixed.

The component for the active route (e.g., Home, About, Contact) will appear inside <router-outlet>.


How It Works (Behind the Scenes)

In app-routing.module.ts, you define your routes:

const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'about', component: AboutComponent },
  { path: 'contact', component: ContactComponent },
];


When the user goes to:

/ ‚Üí Angular loads HomeComponent inside <router-outlet>.

/about ‚Üí Angular replaces that space with AboutComponent.

/contact ‚Üí shows ContactComponent.

So, <router-outlet> acts like a switching area that changes content without reloading the page.




----------------------->  üß© What Are Multiple Router Outlets?    <------------------------------

Normally, you have one <router-outlet> in your app, and Angular loads one component at a time into it (based on the route).

But sometimes, you want different areas of the page to change independently ‚Äî for example:

A main content area

A sidebar, or

A popup/modal panel

üëâ In that case, you use named router outlets ‚Äî more than one outlet on the same page.

üß± Example Scenario

Imagine your layout like this:

---------------------------------
| Header (fixed)                |
---------------------------------
| Sidebar |     Main Content    |
|         |                     |
---------------------------------
| Footer (fixed)                |
---------------------------------


You can use:

One outlet for the main content

Another outlet for the sidebar

üß∞ Step-by-Step Example
üóÇÔ∏è 1. In app.component.html
<header>Header Section</header>

<div class="layout">
  <aside>
    <!-- Sidebar outlet -->
    <router-outlet name="sidebar"></router-outlet>
  </aside>

  <main>
    <!-- Default outlet -->
    <router-outlet></router-outlet>
  </main>
</div>

<footer>Footer Section</footer>


Here:

The unnamed <router-outlet> is the primary outlet (main content).

The named outlet (name="sidebar") is the secondary outlet.

üó∫Ô∏è 2. In app-routing.module.ts

Define routes for both outlets.

const routes: Routes = [
  // Primary outlet route
  { path: 'home', component: HomeComponent },

  // Secondary (named) outlet route
  {
    path: 'menu',
    component: MenuComponent,
    outlet: 'sidebar'
  }
];

üß≠ 3. How to Navigate to Multiple Outlets

You can load both at the same time using named outlet navigation.

Option 1 ‚Äî In the URL directly:
/home(sidebar:menu)


This means:

Load HomeComponent in the main (default) outlet

Load MenuComponent in the sidebar outlet

Option 2 ‚Äî Using Router in TypeScript:
this.router.navigate([{ outlets: { primary: ['home'], sidebar: ['menu'] } }]);

Option 3 ‚Äî Using links in HTML:
<a [routerLink]="[{ outlets: { primary: ['home'], sidebar: ['menu'] } }]">Open Home + Sidebar</a>

üéØ Result

‚úÖ The HomeComponent appears in the main content area.
‚úÖ The MenuComponent appears in the sidebar outlet ‚Äî both on the same page.

You can close or change the sidebar independently without touching the main area.

üí° Use Cases
Use Case	Description
Sidebar or Navigation Panel	Show or hide side menus dynamically
Chat or Notification Pane	Keep the main app while changing a small section
Modal or Overlay	Display a popup without leaving the page
Split Views	Show related content in two places at once
‚ö†Ô∏è Important Notes

The default outlet doesn‚Äôt need a name ‚Äî it‚Äôs automatically called primary.

All other outlets must be named (e.g., sidebar, popup).

Each outlet can have its own set of routes.

Named outlets can even be nested inside child components.




------------------------------------------------>



app.component.css

Purpose: Styles only for this component.

Example:

h1 {
  color: #1976d2;
  text-align: center;
}


What happens if you change:

Styles only affect this component.

Using global selectors here has no effect outside this component.



----------------------------------->

Other components/services

Components ‚Üí Each has .ts, .html, .css.

Services ‚Üí .ts files with @Injectable() providing business logic.

What happens if you change:

Modifying logic in services affects all components using that service.

Changing component template or styles updates only that component.



------------------------------------------->

assets/ folder

Purpose: Static files (images, icons, JSON).

What happens if you change:

Changing or adding files ‚Üí Can be referenced in templates or CSS.

Removing files ‚Üí Breaks references if used in code.



------------------------------------------->

environments/ folder

Purpose: Environment-specific config.

environment.ts (dev)
export const environment = {
  production: false,
  apiUrl: 'http://localhost:3000'
};

environment.prod.ts (prod)
export const environment = {
  production: true,
  apiUrl: 'https://api.myapp.com'
};


What happens if you change:

Changing production ‚Üí Affects Angular build optimizations.

Changing apiUrl ‚Üí Affects where your app sends HTTP requests.


-------------------------------------------------------------------------------->

2. Root project files
angular.json

Purpose: CLI config for builds, styles, assets, scripts.

What happens if you change:

Change outputPath ‚Üí Built files go to a different folder.

Add/remove styles ‚Üí CSS files included/excluded.

Add/remove assets ‚Üí Static files included/excluded in build.



---  What is angular.json?


üß© 1. $schema
"$schema": "./node_modules/@angular/cli/lib/config/schema.json"


Meaning:
This tells VS Code (or your editor) where to find Angular CLI‚Äôs structure rules.
It helps with auto-completion and error highlighting in angular.json.

If you change/remove it:

Angular will still work, but you‚Äôll lose auto-suggestions and error checking for this file in your IDE.
‚úÖ Keep it as is ‚Äî it‚Äôs just for developer convenience.

üß© 2. "version": 1

Meaning:
Represents the schema version used by Angular CLI.
CLI uses it internally to understand how to read this file.

If you change it:

The CLI may throw errors or ignore parts of your configuration.
‚ùå Don‚Äôt change this manually.

üß© 3. "newProjectRoot": "projects"

Meaning:
When you create new projects (using ng generate application or ng g lib),
Angular puts them inside this folder (projects/).

If you change it:

Example: "newProjectRoot": "apps"
Then all new apps/libraries will be created inside an apps folder instead.
‚úÖ Safe to change ‚Äî affects only where new projects are stored.

üß© 4. "projects" and "defaultProject"
"defaultProject": "angular-topics"


Meaning:
This defines which project Angular CLI commands (like ng serve) will use by default.

If you change it:

Example: "defaultProject": "my-other-app"
Then running ng serve will start that app instead.
‚úÖ Change it only if you have multiple apps in one workspace.

üß© 5. "projectType": "application"

Meaning:
Tells Angular CLI that this project is a runnable web app (not a library).

If you change it to "library":

Angular expects public_api.ts etc., not normal app structure.

It‚Äôll break your app build.
‚ùå Don‚Äôt change this unless you‚Äôre intentionally building a library.

üß© 6. "prefix": "app"

Meaning:
Defines what prefix appears before your component selectors.
Example: <app-header> comes from "prefix": "app".

If you change it:

Example: "prefix": "ng"
Then new components will have <ng-header> instead of <app-header>.
‚úÖ Safe to change ‚Äî stylistic choice.
üí° Only affects future generated components, not old ones.

üß© 7. "schematics"
"@schematics/angular:component": { "style": "scss" },
"@schematics/angular:application": { "strict": true }

üëâ style: "scss"

Meaning:
When you create new components using ng g c, it will use SCSS files by default.

If you change it to "css" or "sass":

New components will use that style type automatically.
‚úÖ Safe ‚Äî personal/team preference.

üëâ strict: true

Meaning:
Turns on strict TypeScript settings ‚Äî makes your code safer and catch more bugs early.

If you change it to false:

Angular will be more lenient ‚Äî fewer type checks, fewer compile errors.
‚ö†Ô∏è Easier short term, but can hide bugs in larger projects.

üß© 8. "root" and "sourceRoot"
Key	Meaning	If Changed
"root": ""	Project base folder. Empty = root of workspace.	Usually leave empty.
"sourceRoot": "src"	Where your main app source code lives.	If you rename src folder, update this path ‚Äî else build fails.

‚ùå Changing without moving folders causes file not found errors.

üß© 9. "architect" ‚Üí The core build instructions
‚öôÔ∏è A. "build"
"builder": "@angular-devkit/build-angular:browser"


Means Angular CLI uses the browser builder to compile your app.

üî∏ "options" inside "build"

Let‚Äôs go one by one üëá

1Ô∏è‚É£ "outputPath": "dist/angular-topics"

Meaning:
The folder where your compiled files (HTML, JS, CSS) are saved after build.

If you change it:

Example: "outputPath": "build-output"
Then your build files will go there instead of dist/angular-topics.
‚úÖ Safe ‚Äî just remember to deploy from the new folder.

2Ô∏è‚É£ "index": "src/index.html"

Meaning:
The entry HTML file of your app.

If you change it:

Example: "src/main.html"
Angular will look there to bootstrap your app.
‚ùå Make sure the file actually exists, else build fails.

3Ô∏è‚É£ "main": "src/main.ts"

Meaning:
Your app‚Äôs main entry TypeScript file ‚Äî where Angular bootstraps AppModule.

If you change it:

Example: "src/bootstrap.ts"
Then Angular will start from that file.
‚úÖ Can change only if you rename/move main.ts.

4Ô∏è‚É£ "polyfills": "src/polyfills.ts"

Meaning:
Includes extra scripts for older browser support (e.g., IE).

If you remove/change it:

Old browsers may not work properly.
‚úÖ Keep it unless you target modern browsers only.

5Ô∏è‚É£ "tsConfig": "tsconfig.app.json"

Meaning:
Tells Angular which TypeScript config file to use for the app.

If you change it:

Build will use a different TS config (maybe for special settings).
‚úÖ Safe if you know TypeScript configs.

6Ô∏è‚É£ "inlineStyleLanguage": "scss"

Meaning:
Defines which style language is used when writing inline styles inside .ts files.

If you change it:

Example: "css" ‚Üí then inline styles will expect plain CSS syntax.
‚úÖ Harmless ‚Äî personal/team preference.

7Ô∏è‚É£ "assets": ["src/favicon.ico", "src/assets"]

Meaning:
Files copied as-is to the build output (like images, logos, etc.)

If you remove it:

Your images or favicon won‚Äôt appear in production.
‚úÖ Add more asset paths if needed.

8Ô∏è‚É£ "styles": ["src/styles.scss"]

Meaning:
Global style files applied to the entire app.

If you add more:

"styles": ["src/styles.scss", "src/theme.scss"]


Then Angular will include all in final build.
‚úÖ Safe to add more global styles.

9Ô∏è‚É£ "scripts": []

Meaning:
Used to include external JavaScript libraries (like jQuery or chart.js).

If you add:

"scripts": ["src/assets/js/jquery.min.js"]


It will be globally loaded in your app.
‚úÖ Use only for global (non-Angular) scripts.

üî∏ "configurations"

Different build modes.

Production Configuration

Meaning:
Optimized for deployment ‚Äî smaller, faster, safer.

"budgets": [...]


Warns you if your app gets too big (to keep performance good).

"fileReplacements": [...]


Replaces environment.ts with environment.prod.ts.

If you remove it:

Your production build may still use development APIs. ‚ùå Not recommended.

"outputHashing": "all"


Adds unique hash to file names (for browser cache-busting).
If you remove it ‚Üí old files might stay cached ‚Üí users see old version. ‚ùå Bad for deployment.

Development Configuration

Used when you run ng serve.

"buildOptimizer": false, "optimization": false, "sourceMap": true"


If you set optimization to true:

Code will minify and rebuild slower (not needed for dev).
‚úÖ Keep defaults.

üñ•Ô∏è B. "serve"
"defaultConfiguration": "development"


Meaning:
When you run ng serve, Angular uses development settings by default.

If you change to "production":

Running ng serve will use optimized build ‚Äî slower, not ideal for local testing.
‚úÖ Keep "development" for local work.

üåç C. "extract-i18n"

Meaning:
Used for extracting text for translation (ng extract-i18n).

If you don‚Äôt use multiple languages:

You can ignore it ‚Äî no effect.

üß™ D. "test"

Defines how Angular runs unit tests using Karma.

If you remove or change paths:

Tests won‚Äôt run (ng test will fail).
‚úÖ Usually no need to modify unless customizing test setup.



--------------------------------------------------------------------------->


package.json

Purpose: Dependencies, scripts, app metadata.

What happens if you change:

Add dependencies ‚Üí npm install needed.

Change scripts ‚Üí npm start or ng build behavior changes.

Change version/name ‚Üí Metadata only, no runtime effect.



------
üß© 1Ô∏è‚É£ Basic Info Section
{
  "name": "angular-topics",
  "version": "0.0.0",
  ...
}

üîπ name

This is the project name.

It‚Äôs used when publishing your app as an npm package (though Angular apps usually aren‚Äôt published).

Also used internally by Angular CLI for identifying the project.

‚úÖ Example:

"name": "my-angular-app"


üß† If you change it:
No effect in local development, but if you use monorepos or publish to npm, it changes the identifier.
Change it only for naming clarity or publishing to npm.

üîπ version

Represents your app version.

Used for documentation or deployment tagging.

‚úÖ Example:

"version": "1.0.0"


üß† If you change it:
No effect on app behavior, but helps in version control (especially for release tracking or CI/CD pipelines).

Change it when you make a major/minor update to your app.

üèÉ 2Ô∏è‚É£ Scripts Section
"scripts": {
  "ng": "ng",
  "start": "ng serve",
  "build": "ng build",
  "watch": "ng build --watch --configuration development",
  "test": "ng test"
}


These are shortcuts for common Angular CLI commands.

üîπ "ng": "ng"

Allows you to run npm run ng (same as directly typing ng).

üîπ "start": "ng serve"

Starts the Angular development server on http://localhost:4200.

üß† If you change it:
You can customize the default serve configuration. Example:

"start": "ng serve --port 4500 --open"


‚Üí Will auto-open in browser on port 4500.

üîπ "build": "ng build"

Compiles the app into the dist/ folder for deployment.

üß† If you change it:
You can specify configuration:

"build": "ng build --configuration production"


‚Üí Builds optimized files for deployment.

üîπ "watch": "ng build --watch --configuration development"

Continuously builds the project whenever a file changes (good for debugging library development).

üß† If you change it:
You can switch configuration or add custom watch options.

üîπ "test": "ng test"

Runs the unit tests using Karma + Jasmine.

üß† If you change it:
You can specify a different testing framework (like Jest) if you migrate testing.

üîí 3Ô∏è‚É£ "private": true
"private": true


Prevents your project from being accidentally published to npm.

üß† If you change it to false:
You could publish your app as an npm package ‚Äî not needed for normal Angular apps.

‚öôÔ∏è 4Ô∏è‚É£ Dependencies Section

These are libraries your app needs to run in production.

"dependencies": {
  "@angular/core": "~13.3.0",
  "@angular/router": "~13.3.0",
  "rxjs": "~7.5.0",
  "zone.js": "~0.11.4"
}


Let‚Äôs break it down:

Package	Purpose	What happens if changed
@angular/core	Core Angular framework	Upgrading can break compatibility; upgrade only if you upgrade all Angular packages together
@angular/common	Common directives/pipes (ngIf, ngFor)	Must match same version as core
@angular/compiler	Compiles templates into JS	Version mismatch = build errors
@angular/forms	Template & Reactive forms	Used for <form> handling
@angular/router	Enables page navigation	Needed for <router-outlet>
@angular/platform-browser	Runs app in browser	Always needed for web apps
rxjs	Reactive programming library	Controls Observables, Subjects etc.
tslib	TypeScript helper library	Required for TypeScript runtime
zone.js	Change detection mechanism	Required for Angular to detect changes

üß† When to change:

Only update when upgrading Angular (e.g., via ng update @angular/core).

Never change one Angular package alone ‚Äî all versions must stay aligned.

üßë‚Äçüíª 5Ô∏è‚É£ DevDependencies Section

These are only used for development/build/testing, not in the final deployed app.

"devDependencies": {
  "@angular/cli": "~13.3.11",
  "typescript": "~4.6.2",
  "karma": "~6.3.0",
  "jasmine-core": "~4.0.0"
}

Package	Purpose	If Changed
@angular/cli	CLI tool for building, serving, testing	Must match Angular version (use ng update)
@angular/compiler-cli	CLI compiler	Needed for AOT compilation
@angular-devkit/build-angular	Build system used by CLI	Don‚Äôt downgrade manually
typescript	Language compiler	Upgrading too far may cause errors if Angular doesn‚Äôt support it
karma, jasmine	Testing frameworks	Can replace with Jest or other tools
@types/node, @types/jasmine	TypeScript type definitions	Needed for IntelliSense and compile-time checks

üß† When to change:

During Angular version upgrades or test setup changes.

Example: Replacing karma + jasmine with jest for faster testing.



----------------------------------------------------------->




package-lock.json

Locks exact dependency versions.

Change ‚Üí Normally auto-generated. Manually changing can break dependency tree.



----------------------------------------------------------------->

PACKAGE.JSON VS PACKAGE-LOCK.JSON

üß© 1Ô∏è‚É£ package.json ‚Äî ‚ÄúThe Menu Card‚Äù
üìò What it is:

It lists the names and versions of the packages your project needs.

Think of it like a menu card ‚Äî it tells what you want but not exactly what was served.

üì¶ Example:
"dependencies": {
  "@angular/core": "^13.3.0",
  "rxjs": "~7.5.0"
}

‚öôÔ∏è What it means:

@angular/core ‚Üí you need Angular Core.

^13.3.0 ‚Üí means any version >=13.3.0 and <14.0.0 is allowed (minor updates OK).

~7.5.0 ‚Üí means any version >=7.5.0 and <7.6.0 (patch updates only).

‚úÖ You can edit this file manually to add or remove dependencies.

üîí 2Ô∏è‚É£ package-lock.json ‚Äî ‚ÄúThe Exact Recipe‚Äù
üìò What it is:

It records the exact versions of every installed package (including sub-dependencies).

Think of it like a final detailed recipe ‚Äî it shows exactly what ingredients and quantities were used.

‚öôÔ∏è Example:
"node_modules/@angular/core": {
  "version": "13.3.11",
  "resolved": "https://registry.npmjs.org/@angular/core/-/core-13.3.11.tgz",
  "integrity": "sha512-abc123..."
}


üëâ It locks the versions so every developer (or server) gets the exact same setup.

‚öñÔ∏è 3Ô∏è‚É£ The Main Difference
Feature	package.json	package-lock.json
Purpose	Lists required dependencies	Locks exact versions installed
Editable	Yes (by you)	No (auto-generated by npm)
Version range	Uses ^, ~ (flexible)	Fixed exact versions
Created by	You (or Angular CLI)	Automatically by npm
Needed for deployment	Yes	Yes (to keep builds consistent)
Example version	"rxjs": "~7.5.0"	"rxjs": "7.5.3"
üß† 4Ô∏è‚É£ Why both are needed

‚úÖ package.json ‚Üí Tells which packages your project depends on.
‚úÖ package-lock.json ‚Üí Ensures everyone installs the same versions.

So even if your package.json allows "^13.3.0", the lock file might fix it at "13.3.11" ‚Äî avoiding ‚Äúit works on my system‚Äù issues.

üîÑ 5Ô∏è‚É£ When you delete or change them
üîπ If you delete package-lock.json and run npm install:

npm will re-calculate latest compatible versions from package.json.

Your dependency tree might change slightly.
üëâ Result: app may behave differently if a library update broke something.

üîπ If you delete node_modules but keep package-lock.json:

npm will reinstall exact versions from the lock file ‚Üí safe and consistent.

üß∞ 6Ô∏è‚É£ When to change manually

‚úÖ package.json: You can add, remove, or change versions of dependencies.

‚ùå package-lock.json: Don‚Äôt edit manually ‚Äî npm updates it automatically after every install/uninstall.

üèÅ 7Ô∏è‚É£ Simple Analogy
Real Life Example	Angular/NPM Equivalent
Menu card says ‚ÄúPizza (any size between medium and large)‚Äù	package.json with ^13.3.0
Chef writes down exact recipe: ‚ÄúPizza, medium, 12-inch, mozzarella brand A‚Äù	package-lock.json

So:
üßæ package.json = ‚ÄúWhat you ordered.‚Äù
üîê package-lock.json = ‚ÄúExactly what you got.‚Äù



---------------------------------------------------------------------------->

tsconfig.json

Configures TypeScript compiler.

Change target ‚Üí Affects generated JS version.

Change module ‚Üí Affects module loading system.


üß© What is tsconfig.json?

It‚Äôs the TypeScript configuration file for your Angular project.

It tells the TypeScript compiler how to convert .ts (TypeScript) files into .js (JavaScript).

Angular uses it behind the scenes whenever you run:

ng serve
ng build

‚öôÔ∏è Top-Level Options
"compileOnSave": false


‚ùì Meaning: When true, automatically recompiles files on save (in editors like VS Code).

üí° Default in Angular: Usually false, because Angular CLI already watches and recompiles automatically.

üß† If you change it to true:
Your editor may recompile TypeScript files on every save (not needed for Angular CLI projects).

üß† compilerOptions ‚Äî These control how TypeScript behaves.
1Ô∏è‚É£ "baseUrl": "./"

Sets the root path for module imports.
Example: if "baseUrl": "./src", you can import like this:

import { MyService } from "app/services/my.service";


instead of

import { MyService } from "../../services/my.service";


‚ö†Ô∏è If you change it, all import paths must match the new base directory.

2Ô∏è‚É£ "outDir": "./dist/out-tsc"

Tells TypeScript where to store compiled .js files.

Angular later takes them and bundles for deployment.

üß† If you change it:
Compiled files will go to a different folder (but normally don‚Äôt touch this ‚Äî Angular manages it).

3Ô∏è‚É£ "forceConsistentCasingInFileNames": true

Ensures file imports use exact same letter case (e.g., User.ts ‚â† user.ts).

Prevents cross-platform bugs (especially between Windows & Linux).

üß† If false: Case-insensitive imports might cause build failures on Linux servers.

4Ô∏è‚É£ "strict": true

Enables TypeScript strict mode, enforcing strict type checks everywhere.

Helps catch more errors early.

üß† If you turn it off:
You‚Äôll have fewer type errors, but also less safety.
‚úÖ Recommended: Keep it true for production-level Angular apps.

5Ô∏è‚É£ "noImplicitOverride": true

Ensures that if you override a method from a parent class, you must use the override keyword.

class A { greet() {} }
class B extends A {
  override greet() {} // ‚úÖ required
}


üß† If false: TypeScript won‚Äôt warn you if you accidentally shadow a parent method.

6Ô∏è‚É£ "noPropertyAccessFromIndexSignature": true"

Prevents accidental access to properties that don‚Äôt exist in an object with an index signature.

üß† Example:

let obj: { [key: string]: string } = { name: "John" };
obj.name; // ‚ùå error if true (forces obj["name"])


üß† If false: You can access like obj.name, but type checking becomes weaker.

7Ô∏è‚É£ "noImplicitReturns": true"

Warns you if a function can exit without returning a value.

üß† If false: A function may miss a return statement, leading to bugs.

8Ô∏è‚É£ "noFallthroughCasesInSwitch": true"

Prevents fallthrough errors in switch statements.

üß† Example:

switch (x) {
  case 1:
    doSomething();
  case 2:
    doSomethingElse(); // ‚ùå warning if no 'break'
}

9Ô∏è‚É£ "sourceMap": true"

Generates source maps that map compiled JS back to your TS code ‚Äî useful for debugging in browser dev tools.

üß† If false: You won‚Äôt see TypeScript lines in browser debugging.

üîü "declaration": false"

When true, generates .d.ts (type definition) files.

Used when building libraries, not normal apps.

üß† If you change to true:
It‚Äôll generate type declaration files for every component ‚Äî not needed unless you‚Äôre publishing a library.

11Ô∏è‚É£ "downlevelIteration": true"

Ensures correct iteration behavior for older browsers (like IE11) when using loops like for..of.

üß† If false:
Some loops might behave incorrectly on old browsers.

12Ô∏è‚É£ "experimentalDecorators": true"

Allows using decorators like @Component, @Injectable, etc.

‚ö†Ô∏è Without this, Angular won‚Äôt compile at all, since decorators are core to Angular.

üß† Never disable this.

13Ô∏è‚É£ "moduleResolution": "node"

Tells TypeScript how to find modules (like Node.js does).

üß† If changed to 'classic':
Imports may break because Angular expects Node-style module resolution.

14Ô∏è‚É£ "importHelpers": true"

Reduces code duplication by importing helper functions from tslib instead of embedding them in every file.

üß† If false: Final JS bundle size slightly increases.

15Ô∏è‚É£ "target": "es2017"

Defines which JavaScript version TypeScript should compile to.

es2017 means code will use modern JS features supported by most browsers.

üß† If changed:

Lower (es5) ‚Üí Works on old browsers but slower and heavier.

Higher (es2020) ‚Üí Modern, faster, but may not support old browsers.

16Ô∏è‚É£ "module": "es2020"

Defines how JS modules are handled.

es2020 ‚Üí Uses modern import/export syntax.

üß† If changed to commonjs:
Might break Angular‚Äôs build system (Angular expects ES modules).

17Ô∏è‚É£ "lib": ["es2020", "dom"]

Defines built-in features your code can use:

es2020 ‚Üí Modern JS features (Promises, async/await, etc.)

dom ‚Üí Browser APIs (like document, window)

üß† If you remove 'dom':
You can‚Äôt use browser objects like document or window.

üåç angularCompilerOptions

These are specific to Angular‚Äôs compiler (not plain TypeScript).

1Ô∏è‚É£ "enableI18nLegacyMessageIdFormat": false

Controls how Angular handles i18n (internationalization) message IDs.

false means it uses new, consistent message formats.

üß† If true: Old message formats used; only needed for backward compatibility.

2Ô∏è‚É£ "strictInjectionParameters": true"

Makes Angular check that all constructor dependencies are properly provided.

üß† If false:
Angular won‚Äôt warn you if a service or dependency is missing ‚Äî could cause runtime errors.

3Ô∏è‚É£ "strictInputAccessModifiers": true"

Ensures @Input() properties respect visibility (e.g., private/protected restrictions).

üß† If false:
You can access private inputs in templates ‚Äî unsafe and confusing.

4Ô∏è‚É£ "strictTemplates": true"

Enables strict type checking inside templates (HTML).

Helps catch errors like wrong variable names, type mismatches, etc.

üß† If false:
Angular won‚Äôt warn if your template uses undefined variables.



---------------------------------------------------------------->

tsconfig.app.json

TS config specific to app source.

Change include paths ‚Üí May exclude files from compilation.



This file defines how TypeScript should compile your Angular app code (not tests or e2e ‚Äî only src/app).

‚öôÔ∏è Explanation Line by Line
"extends": "./tsconfig.json"

It means this file inherits settings from the main tsconfig.json.

So it doesn‚Äôt repeat everything ‚Äî only overrides or adds app-specific settings.

"compilerOptions": { "outDir": "./out-tsc/app", "types": [] }

outDir ‚Üí Compiled .js files go to this folder (/out-tsc/app).

types: [] ‚Üí Means no global type definitions are added automatically (to keep app build clean).

"files": [ "src/main.ts", "src/polyfills.ts" ]

These are entry point files for the app build.

main.ts ‚Üí Bootstraps the Angular app.

polyfills.ts ‚Üí Adds browser compatibility support.

"include": [ "src/**/*.d.ts" ]

Includes all TypeScript declaration files (.d.ts) in the src folder.

These are files that describe the types of third-party or custom code.

üß† In Simple Terms

Think of it like this:

tsconfig.json = main global rules.
tsconfig.app.json = rules specific to your Angular app code.



----------------------------------------------------------------->

tsconfig.spec.json

TS config for unit tests.

Change include or exclude ‚Üí Affects which files tests run on.


This file is used when running tests (like with Karma or Jasmine).
It tells TypeScript which files to compile and what special settings to use during testing.


----------------------------------------------------------------->

karma.conf.js

Configuration for unit test runner Karma.

Change browsers ‚Üí Tests run in different browsers.

Change frameworks/plugins ‚Üí Changes test environment.

browserslist

Defines supported browsers.

Change here ‚Üí Affects compiled JS and CSS for different browsers.




----------------------------------------------------------------->

.editorconfig

Editor formatting rules (indentation, line endings).

Change ‚Üí Only affects how code looks in supported editors.




.editorconfig ensures consistent code formatting ‚Äî
for example, the same indentation, charset, and newline rules, no matter which editor (VS Code, WebStorm, etc.) your team uses.

‚öôÔ∏è Line-by-Line Explanation
root = true

This means this file is the root of all EditorConfig settings.

Editors will stop searching upward for other .editorconfig files once this is found.

[*]

Applies settings below to all files in the project.

charset = utf-8

üëâ All files should use UTF-8 encoding (standard text encoding).

indent_style = space

üëâ Use spaces (not tabs) for indentation.

indent_size = 2

üëâ Each indentation level = 2 spaces.

insert_final_newline = true

üëâ Ensures every file ends with a new blank line ‚Äî helps avoid merge issues.

trim_trailing_whitespace = true

üëâ Removes any extra spaces at the end of a line when saving.

[*.ts]

üëâ These rules apply only to TypeScript files (.ts).

quote_type = single

üëâ Use single quotes ' ' for strings, not double quotes " ".

[*.md]

üëâ These rules apply only to Markdown files (.md).

max_line_length = off

üëâ Don‚Äôt wrap lines automatically ‚Äî Markdown files can have long lines.

trim_trailing_whitespace = false

üëâ Don‚Äôt remove trailing spaces ‚Äî they may be used for formatting in Markdown.



----------------------------------------------------------------->

.gitignore

Files Git should ignore.

Change ‚Üí Affects which files are tracked in Git.





----------------------------------------------------------------->

README.md

Instructions for setup, run, and build.

Change ‚Üí Only affects documentation, not app behavior.